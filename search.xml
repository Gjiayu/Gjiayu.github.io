<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题-Vue系列</title>
      <link href="/2021/07/08/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/07/08/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Vue优点"><a href="#Vue优点" class="headerlink" title="Vue优点"></a>Vue优点</h2><pre><code>1. 轻量级框架2. 简单易学3. 双向数据绑定4. 视图、数据、解构分离5. 虚拟Dom6. 运行速度更快</code></pre><h2 id="Vue父组件向子组件传递数据"><a href="#Vue父组件向子组件传递数据" class="headerlink" title="Vue父组件向子组件传递数据"></a>Vue父组件向子组件传递数据</h2><pre><code>通过props</code></pre><h2 id="Vue子组件向父组件传递事件"><a href="#Vue子组件向父组件传递事件" class="headerlink" title="Vue子组件向父组件传递事件"></a>Vue子组件向父组件传递事件</h2><pre><code>$emit方法</code></pre><h2 id="如何获取dom"><a href="#如何获取dom" class="headerlink" title="如何获取dom"></a>如何获取dom</h2><pre><code>ref=&quot;domName&quot;   用法：this.$refs.domName</code></pre><h2 id="Vue-loader是什么-使用它的用途有哪些？"><a href="#Vue-loader是什么-使用它的用途有哪些？" class="headerlink" title="Vue-loader是什么?使用它的用途有哪些？"></a>Vue-loader是什么?使用它的用途有哪些？</h2><pre><code>Vue文件的一个加速器，将template/Js/style转换为js模块。用法：js可以写es6、style样式可以scss或less、template可以加jade等</code></pre><h2 id="为什么使用key？"><a href="#为什么使用key？" class="headerlink" title="为什么使用key？"></a>为什么使用key？</h2><pre><code>需要使用key来给每个节点做一个唯一标识、Diff算法可以正确识别此节点作用主要是为了搞高效的更新虚拟Dom</code></pre><h2 id="axios及安装"><a href="#axios及安装" class="headerlink" title="axios及安装"></a>axios及安装</h2><pre><code>请求后台资源模块。npm install axios --savejs中使用import进来，然后get或post。返回在.then函数中如果成功，失败则在.catch函数中</code></pre><h2 id="请说出Vue-cil项目中src目录每个文件夹和文件的用法"><a href="#请说出Vue-cil项目中src目录每个文件夹和文件的用法" class="headerlink" title="请说出Vue.cil项目中src目录每个文件夹和文件的用法"></a>请说出Vue.cil项目中src目录每个文件夹和文件的用法</h2><pre><code>assets文件夹是放静态文件的components是放组件router是定义路由相关配置app.vue是一个应用主组件main.js是入口组件</code></pre><h2 id="v-on可以监听多个方法吗"><a href="#v-on可以监听多个方法吗" class="headerlink" title="v-on可以监听多个方法吗"></a>v-on可以监听多个方法吗</h2><pre><code>可以例子：&lt;input type=&quot;text&quot; v-on=&quot;&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;&quot;&gt;。</code></pre><h2 id="nextTick的使用"><a href="#nextTick的使用" class="headerlink" title="$nextTick的使用"></a>$nextTick的使用</h2><pre><code>当你修改了data的值然后马上获取这个dom元素的值，是不能获取到更新后的值，你需要使用$nextTick这个回调，让修改后的data值渲染更新到dom元素之后在获取，才能成功</code></pre><h2 id="渐进式框架的理解"><a href="#渐进式框架的理解" class="headerlink" title="渐进式框架的理解"></a>渐进式框架的理解</h2><pre><code>主张最少；可以根据不同需求选择不同层级；</code></pre><h2 id="vue组件中data为什么必须是一个函数？"><a href="#vue组件中data为什么必须是一个函数？" class="headerlink" title="vue组件中data为什么必须是一个函数？"></a>vue组件中data为什么必须是一个函数？</h2><pre><code>因为JavaScript的特性所导致，在component中，data必须以函数的形式存在，不可以是对象。组建中的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个data，这样改一个全都改了。</code></pre><h2 id="单页面应用和多页面应用区别及优缺点"><a href="#单页面应用和多页面应用区别及优缺点" class="headerlink" title="单页面应用和多页面应用区别及优缺点"></a>单页面应用和多页面应用区别及优缺点</h2><pre><code>单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新单页面的优点：用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。单页面缺点：不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。</code></pre><h2 id="v-if和v-for的优先级"><a href="#v-if和v-for的优先级" class="headerlink" title="v-if和v-for的优先级"></a>v-if和v-for的优先级</h2><pre><code>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。所以，不推荐v-if和v-for同时使用。如果v-if和v-for一起用的话，vue中的的会自动提示v-if应该放到外层去</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web前端面试题整理，阶段性</title>
      <link href="/2021/07/08/%E5%89%8D%E6%AE%B5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/07/08/%E5%89%8D%E6%AE%B5%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="列举数组的迭代方法"><a href="#列举数组的迭代方法" class="headerlink" title="列举数组的迭代方法"></a>列举数组的迭代方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map / forEach / filter / find / findIndex / every / some / reduce</span><br></pre></td></tr></table></figure><h2 id="以下方法的参数都是promise的数组，简要描述Promise-all-Promise-any-Promise-race-Promise-allSettled的返回的promise状态为成功或失败的条件。"><a href="#以下方法的参数都是promise的数组，简要描述Promise-all-Promise-any-Promise-race-Promise-allSettled的返回的promise状态为成功或失败的条件。" class="headerlink" title="以下方法的参数都是promise的数组，简要描述Promise.all / Promise.any / Promise.race / Promise.allSettled的返回的promise状态为成功或失败的条件。"></a>以下方法的参数都是promise的数组，简要描述Promise.all / Promise.any / Promise.race / Promise.allSettled的返回的promise状态为成功或失败的条件。</h2><pre><code>Promise.all：全部成功时成功，任意一个失败时失败Promise.any：任意一个成功时成功，全部失败时失败Promise.race：最快改变状态的promise成功则成功，如果失败则失败Promise.allSettled：如果参数promise数组全都改变状态了就成功，不会失败</code></pre><h2 id="使用Set伪数组arr去重"><a href="#使用Set伪数组arr去重" class="headerlink" title="使用Set伪数组arr去重"></a>使用Set伪数组arr去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(arr)]</span><br></pre></td></tr></table></figure><h2 id="跨页面存储数据有哪些方法"><a href="#跨页面存储数据有哪些方法" class="headerlink" title="跨页面存储数据有哪些方法"></a>跨页面存储数据有哪些方法</h2><pre><code>cookielocalStoragesessionStorage（web storage）</code></pre><h2 id="cookie的特点"><a href="#cookie的特点" class="headerlink" title="cookie的特点"></a>cookie的特点</h2><pre><code>单条大小4096字节（4kb）单个域名下的cookie数量有限可以跨页面、游览器生存周期存在可以设置域、路径、过期时间兼容性好，几乎所有游览器都支持</code></pre><h2 id="video如何插入多个视频源？"><a href="#video如何插入多个视频源？" class="headerlink" title="video如何插入多个视频源？"></a>video如何插入多个视频源？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line">&lt;source&gt;&lt;/source&gt;</span><br><span class="line">&lt;source&gt;&lt;/source&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure><h2 id="video"><a href="#video" class="headerlink" title="video"></a>video</h2><p>video中如何显示当前播放时间？</p><pre><code>currentTime</code></pre><p>video如何知道视频播放完了？</p><pre><code>ended</code></pre><p>video如何播放？</p><pre><code>play()</code></pre><p>video如何暂停？</p><pre><code>pause()</code></pre><p>video如何预加载？</p><pre><code>preload属性</code></pre><h2 id="map-forEach等迭代方法的第一个参数是回调函数，回调函数的参数有几个，各代表什么含义？"><a href="#map-forEach等迭代方法的第一个参数是回调函数，回调函数的参数有几个，各代表什么含义？" class="headerlink" title="map/forEach等迭代方法的第一个参数是回调函数，回调函数的参数有几个，各代表什么含义？"></a>map/forEach等迭代方法的第一个参数是回调函数，回调函数的参数有几个，各代表什么含义？</h2><pre><code>最多3个参数function(item, index, arraySelf) &#123;...&#125;分别代表 item - 数组的元素 index该元素的下标 arraySelf被迭代数组自己</code></pre><h2 id="数组-map的回调函数需要返回值吗？如需要返回什么内容？"><a href="#数组-map的回调函数需要返回值吗？如需要返回什么内容？" class="headerlink" title="数组.map的回调函数需要返回值吗？如需要返回什么内容？"></a>数组.map的回调函数需要返回值吗？如需要返回什么内容？</h2><pre><code>需要，可以返回任意内容</code></pre><h2 id="数组-filter方法的回调函数需要返回值吗？如果需要，返回什么内容？"><a href="#数组-filter方法的回调函数需要返回值吗？如果需要，返回什么内容？" class="headerlink" title="数组.filter方法的回调函数需要返回值吗？如果需要，返回什么内容？"></a>数组.filter方法的回调函数需要返回值吗？如果需要，返回什么内容？</h2><pre><code>需要 返回true/false</code></pre><h2 id="字符串模版应该用什么引号？"><a href="#字符串模版应该用什么引号？" class="headerlink" title="字符串模版应该用什么引号？"></a>字符串模版应该用什么引号？</h2><pre><code>反引号 ``反引号字符串比普通字符串有什么区别？里面可以写多行文本里面可以用$&#123;...&#125;插入表达式</code></pre><h2 id="如何得到实例（instance）上的原型"><a href="#如何得到实例（instance）上的原型" class="headerlink" title="如何得到实例（instance）上的原型"></a>如何得到实例（instance）上的原型</h2><pre><code>instance.proto或 Object.getPrototypeOf(instance)</code></pre><h2 id="function存在变量提升现象吗？class呢？"><a href="#function存在变量提升现象吗？class呢？" class="headerlink" title="function存在变量提升现象吗？class呢？"></a>function存在变量提升现象吗？class呢？</h2><pre><code>function会变量提升，class不会</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20道面试题(ajax/html/css/vue/react)</title>
      <link href="/2021/07/08/%E6%80%BB%E7%BB%9320%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/07/08/%E6%80%BB%E7%BB%9320%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ajax的优缺点"><a href="#ajax的优缺点" class="headerlink" title="ajax的优缺点"></a>ajax的优缺点</h2><p>优点：</p><pre><code>1. 最大的一点就是页面无刷新，用户体验极好2. 使用异步方式与服务器通信，速度更快3. 把以前服务器负担的工作转嫁给客户端，利用客户端闲置能力来处理，节省空间和宽带租用成本</code></pre><p>缺点：</p><pre><code>1. 不支持游览器的back按钮2. 安全性ajax暴露与服务器交互的细节3. 对搜索引擎的支持比较弱4. 破坏了程序的寻常操作5. 不容易调试</code></pre><h2 id="vuex工作原理"><a href="#vuex工作原理" class="headerlink" title="vuex工作原理"></a>vuex工作原理</h2><pre><code>客户端操作事件，dispatch调用事件action，对应action处理参数，commit一个type类型，mutations接收一个type类型并触发对应函数，修改state，state修改后重新渲染</code></pre><h2 id="ajax是什么？ajax的作用是什么？"><a href="#ajax是什么？ajax的作用是什么？" class="headerlink" title="ajax是什么？ajax的作用是什么？"></a>ajax是什么？ajax的作用是什么？</h2><pre><code>ajax=异步js和xml。ajax是一种快速搭建动态网站的技术。通过在后台和服务器进行少量的数据交互，ajax可以是页面实现异步更新。</code></pre><h2 id="vue的生命周期，那个函数中执行异步请求"><a href="#vue的生命周期，那个函数中执行异步请求" class="headerlink" title="vue的生命周期，那个函数中执行异步请求"></a>vue的生命周期，那个函数中执行异步请求</h2><pre><code>创建：beforeCreate和Created挂载：boforeMount和Mounted更新：beforeUpdate和Updated销毁：beforeDistory和Distoryed在Mounted中执行异步请求</code></pre><h2 id="有两个div，外框和内宽高度宽度都不一定，内宽垂直水平居中，利用css如何实现"><a href="#有两个div，外框和内宽高度宽度都不一定，内宽垂直水平居中，利用css如何实现" class="headerlink" title="有两个div，外框和内宽高度宽度都不一定，内宽垂直水平居中，利用css如何实现"></a>有两个div，外框和内宽高度宽度都不一定，内宽垂直水平居中，利用css如何实现</h2><p>第一种<br><a href="https://www.gjiayu.com/2021/06/14/%E5%B7%A5%E4%BD%9C%E5%AE%A4%E7%AC%94%E8%AF%95%E9%A2%98/" class="button--animated" id="card-info-btn">参考第四题</a></p><p>第二章</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.children&#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    top:<span class="number">50</span>%;</span><br><span class="line">    left:<span class="number">50</span>%;</span><br><span class="line">    transform:translate(-<span class="number">50</span>%,-<span class="number">50</span>%)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ajax适用和不适用场景"><a href="#ajax适用和不适用场景" class="headerlink" title="ajax适用和不适用场景"></a>ajax适用和不适用场景</h2><p>适用：</p><pre><code>1.表单驱动的交互2.深层次的树的导航3.快速的用户与用户间的交流响应4.类似投票，yes/on等无痛痒的场景5.对数据进行过滤和操纵相关数据的场景6.普通的文本输入提示和自动完成的场景</code></pre><p>不适用：</p><pre><code>1.部分简单的表单2.搜索3.基本的导航4.替换大量的文本5.等于呈现的操纵</code></pre><h2 id="mvvm框架是什么？"><a href="#mvvm框架是什么？" class="headerlink" title="mvvm框架是什么？"></a>mvvm框架是什么？</h2><pre><code>Vue实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层</code></pre><h2 id="vue中v-for需要注意什么？为什么要加key？"><a href="#vue中v-for需要注意什么？为什么要加key？" class="headerlink" title="vue中v-for需要注意什么？为什么要加key？"></a>vue中v-for需要注意什么？为什么要加key？</h2><pre><code>需要加key，因为虚拟dom计算需要使用key做遍历优化</code></pre><h2 id="react生命周期"><a href="#react生命周期" class="headerlink" title="react生命周期"></a>react生命周期</h2><pre><code>一、挂载constructor()componentDidmount()二、更新render()componentDidUpdate()三、销毁componentWillUnmount()</code></pre><h2 id="写出三种常见的props的应用场景，还能使用什么进行父子通信"><a href="#写出三种常见的props的应用场景，还能使用什么进行父子通信" class="headerlink" title="写出三种常见的props的应用场景，还能使用什么进行父子通信"></a>写出三种常见的props的应用场景，还能使用什么进行父子通信</h2><pre><code>1.父传子2.props.children接受父组件传入的数据3.子传父用callback函数4.props接受组件</code></pre><h2 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h2><pre><code>1.它使用虚拟Dom而不是真正的Dom2.它可以用服务器端渲染3.它遵循单项数据流和数据绑定</code></pre><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><pre><code>200请求成功，在服务器中获取304请求成功，在缓存中获取400请求语法错误，服务器无法解析403禁止请求404请求地址找不到405请求方式不允许500服务器错误</code></pre><h2 id="简要描述Promise-all-Promise-any-Promise-race-Promise-allSettled的返回的promise状态为成功或失败的条件"><a href="#简要描述Promise-all-Promise-any-Promise-race-Promise-allSettled的返回的promise状态为成功或失败的条件" class="headerlink" title="简要描述Promise.all / Promise.any / Promise.race / Promise.allSettled的返回的promise状态为成功或失败的条件"></a>简要描述Promise.all / Promise.any / Promise.race / Promise.allSettled的返回的promise状态为成功或失败的条件</h2><pre><code>Promise.all：全部成功时成功，任意一个失败时失败Promise.any：任意一个成功时成功，全部失败时失败Promise.race：最快改变状态的promise成功则成功，如果失败则失败Promise.allSettled：如果参数promise数组全都改变状态了就成功，不会失败</code></pre><h2 id="Vue路由的实现原理"><a href="#Vue路由的实现原理" class="headerlink" title="Vue路由的实现原理"></a>Vue路由的实现原理</h2><pre><code>hash和history</code></pre><h2 id="react-中事件-this-绑定的实现方法有哪些"><a href="#react-中事件-this-绑定的实现方法有哪些" class="headerlink" title="react 中事件 this 绑定的实现方法有哪些"></a>react 中事件 this 绑定的实现方法有哪些</h2><pre><code>1.es6箭头函数2.在constructor中绑定3.调用时以箭头函数4.在调用时直接绑定</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习总结</title>
      <link href="/2021/06/16/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2021/06/16/%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="面向对象过程"><a href="#面向对象过程" class="headerlink" title="面向对象过程"></a>面向对象过程</h2><p><strong>（语言，不断创建函数，调用函数，执行函数）</strong></p><pre><code>含义：    为了处理更大，更多需求，基于面向过程衍生出来的一种思想好处：    1. 它是一种更符合人类思维逻辑客观的思想    2. 将复杂的问题简单化    3. 让我们从执行者变成指挥者</code></pre><h2 id="创建函数的三种方式"><a href="#创建函数的三种方式" class="headerlink" title="创建函数的三种方式"></a>创建函数的三种方式</h2><pre><code>1. 通过调用系统更早函数来创建2. 自定义构造函数的方式3. 字面量方式创建</code></pre><h2 id="创建对象做了哪些事"><a href="#创建对象做了哪些事" class="headerlink" title="创建对象做了哪些事"></a>创建对象做了哪些事</h2><pre><code>1. 在堆内存申请一块空间，用来存储对象的内容2. 让this指向该对象3. 为对象进行初始化4. 返回该对象</code></pre><h2 id="this对象的特点"><a href="#this对象的特点" class="headerlink" title="this对象的特点"></a>this对象的特点</h2><pre><code>1. 函数作为一个对象的方法，被该对象所调用，那么this指向的事该对象2. 一般函数直接执行，内部this指向全局window3. 函数作为一个对象方法，被该对象调用，那么this指向的是该对象4. 构造函数中的this其实就是一个隐式对象，类似一个初始化模型，包含所有方法和属性，通过new关键字来调用，从而实现实例化</code></pre><h2 id="无法判断定义的对象是属于那种具体的类型"><a href="#无法判断定义的对象是属于那种具体的类型" class="headerlink" title="无法判断定义的对象是属于那种具体的类型"></a>无法判断定义的对象是属于那种具体的类型</h2><pre><code>1. 工厂函数模式创建对象（函数封装）2. 另一种方式设置和获取值</code></pre><h2 id="HTML和XML的区别"><a href="#HTML和XML的区别" class="headerlink" title="HTML和XML的区别"></a>HTML和XML的区别</h2><pre><code>1. HTML（语法松散，所有标签都是预定义，主要用来展示数据）2. XML（语法严格，所有标都是自定义，主要来存储和传输数据）</code></pre><h2 id="document获取元素的方式"><a href="#document获取元素的方式" class="headerlink" title="document获取元素的方式"></a>document获取元素的方式</h2><pre><code>1. getElementById：根据id属性值来获取元素，返回的是一个Dom对象2. getElementByTagName：根据标签名获取元素，返回的是一个伪数组3. getElementByClassName：根据类样式获取元素，返回的是一个伪数组4. getElementByName：根据那么属性值获取元素，返回的是一个伪数组5. querySelector：根据选择器获取元素，返回的是一个Dom对象6. querySelectorAll：根据选择器获取元素，返回的是一个伪数组，不能用id</code></pre><h2 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h2><ul><li>获取自定义属性的方式</li></ul><pre><code>getAttribute（自定义属性名）</code></pre><ul><li>设置自定义属性的方式</li></ul><pre><code>setAttribute（自定义属性名，属性值）</code></pre><ul><li>移除自定义属性的方式</li></ul><pre><code>removeAttribute（自定义属性名）</code></pre><h2 id="组织事件冒泡"><a href="#组织事件冒泡" class="headerlink" title="组织事件冒泡"></a>组织事件冒泡</h2><pre><code>e.stopPropagation</code></pre><h2 id="阻止事件默认行为"><a href="#阻止事件默认行为" class="headerlink" title="阻止事件默认行为"></a>阻止事件默认行为</h2><pre><code>return falsee.eventDefault</code></pre><h2 id="五大游览器及内核"><a href="#五大游览器及内核" class="headerlink" title="五大游览器及内核"></a>五大游览器及内核</h2><table><thead><tr><th>内核</th><th>浏览器</th></tr></thead><tbody><tr><td>Trident</td><td>IE</td></tr><tr><td>谷歌和苹果</td><td>谷歌和苹果</td></tr><tr><td>Geocko</td><td>火狐</td></tr><tr><td>Presto</td><td>欧鹏</td></tr></tbody></table><h2 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h2><ol><li><p>原始数据类型</p><pre><code> Number数字 Boolean布尔 String字符串 undefinde未定义 Null空</code></pre></li><li><p>引用数据类型</p><pre><code> Array数组 Object对象 Function函数</code></pre></li></ol><ul><li>原始数据类型存储于栈（存储数值）</li><li>引用数据类型存储于堆（存储地址）</li></ul><p><strong>原始和引用传参的区别</strong>:</p><pre><code>原始数据类型传的是一个值引用数据类型传的是一个地址</code></pre><h2 id="js组成部分"><a href="#js组成部分" class="headerlink" title="js组成部分"></a>js组成部分</h2><pre><code>1. ECMAscript2. DOM3. BOM</code></pre><ul><li>a++、a– 先给值后计算</li><li>++a、–a先计算后给值</li></ul><h2 id="NaN是否等于自己"><a href="#NaN是否等于自己" class="headerlink" title="NaN是否等于自己"></a>NaN是否等于自己</h2><pre><code>NaN不等于任何值包括自己NaN==NaN falseNaN（非数）</code></pre><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><p><strong>String动态方法</strong></p><blockquote><ol><li>CharAt：返回指定下标的字符从0开始</li><li>CharCodeAt：返回在指定位置的字符的Unicode编码</li><li>FormCharCode：接受以一个指定的Unicode值，然后返回一个字符串</li></ol></blockquote><blockquote><ol><li>Indexof：返回指定字符串的下标的位置，找不到就返回一个-1；如果出现多次字符串，返回第一次出现的位置</li><li>lastIndexof：返回指定字符串的位置，如果没有返回-1；如果出现多次字符串，返回最后出现的位置</li></ol></blockquote><blockquote><ol><li>substr：输出指定下标后面指定长度的字符串</li><li>substring（正数，正数）：输出指定下标到结束下标的字符串，比substr更严谨</li></ol></blockquote><blockquote><ol><li>slice（正负数，正负数）输出开始下标到结束下表，两个参数可正可负</li><li>split：输出字符串以指定字符串分隔伪数组</li><li>search：输出指定字符下标位置</li><li>toLowerlase：将字符串全部转换为小写</li><li>toUpperLase：将字符串全部转换为大写</li><li>trim：用于删除字符串左右的空格</li></ol></blockquote><h2 id="构造函数（万物之源）"><a href="#构造函数（万物之源）" class="headerlink" title="构造函数（万物之源）"></a>构造函数（万物之源）</h2><p><strong>执行过程</strong>：</p><pre><code>js隐式创建一个空对象js将构造函数的this指向空对象，那么当前函数的this就是隐式创建的空对象通过this给空对象绑定属性js隐式返回绑定好属性的空对象</code></pre><p><strong>弊端</strong>：</p><pre><code>如果忘记用new调用函数，那么this指向window，不仅得不到对象，不会造成全局变量的污染</code></pre><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><pre><code>普通函数/闭包/回调this——&gt;window方法函数this——&gt;调用方法的对象事件处理函数this——&gt;事件源构造函数this——&gt;对象</code></pre><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><p><strong>函数</strong></p><pre><code>.call（要改变this，原函数需要实参）（立即执行）.apply（要改变this，原函数要参数）（立即执行）.bind（要改变this，原函数需要参数）（延迟执行）</code></pre><h2 id="this优先级"><a href="#this优先级" class="headerlink" title="this优先级"></a>this优先级</h2><pre><code>new实例化&gt;bind&gt;call/apply&gt;默认this指向</code></pre><h2 id="构造函数与原型和对象区别"><a href="#构造函数与原型和对象区别" class="headerlink" title="构造函数与原型和对象区别"></a>构造函数与原型和对象区别</h2><p><img src="/https://cdn.jsdelivr.net/gh/gjiayu/picture@master/%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB.png" alt="alt text"></p><h2 id="斐波那契的原理"><a href="#斐波那契的原理" class="headerlink" title="斐波那契的原理"></a>斐波那契的原理</h2><pre><code>用文字来说，就是斐波那契数列由0和1开始，之后的斐波那契数就是由之前的两数相加而得出</code></pre><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><pre><code>原型里有对象，对象里有原型</code></pre><h2 id="面向编程"><a href="#面向编程" class="headerlink" title="面向编程"></a>面向编程</h2><p><strong>面向过程</strong></p><pre><code>优点：符合人类逻辑，代码易于编写缺点：耦合度高，一处报错，全局瘫痪</code></pre><p><strong>面向函数</strong></p><pre><code>优点：解决了耦合度高的问题缺点：全局变量污染，易导致内存溢出</code></pre><p><strong>面向对象</strong></p><pre><code>优点：解决了以上两大缺点缺点：不符合人类逻辑，代码不易于编写</code></pre><h2 id="同步异步的区别"><a href="#同步异步的区别" class="headerlink" title="同步异步的区别"></a>同步异步的区别</h2><pre><code>同步是堵塞模式，异步是非堵塞模式</code></pre><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p><strong>静态方法</strong></p><blockquote><ol><li>concat：用于合并两个或多个数组，此方法不会改变现有数组，而是返回一个新数组</li><li>push：往数组末尾追加元素,返回新的数组长度,改变原数组</li><li>pop：删除数组最后一个元素,返回被删除的元素,改变原数组</li><li>unshift();往数组首位添加元素,返回新数组的长度,改变原数组</li><li>shift：删除数组第一个元素,返回被删除的元素,改变原数组</li><li>splice： 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</li><li>sort：数组排序 默认通过ASCII排序， 对数字排序不好使，所以sort提供一个可编程接口</li><li>join:数组转成字符串</li><li>forEach：遍历数组中的每一项</li><li>slice ：方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。</li></ol></blockquote><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul><li>主要用于解决回调地域问题</li></ul><p><strong>做一件事需要四个步骤</strong></p><pre><code>1. 登录功能2. 列表信息3. 某条列表中的某条数据详情4. 看到某条数据详情才可以对这条数据进行增删改查</code></pre><p>⭐<strong>es6规定Promise对象是一个构造函数，用来生成一个promise实例,构造函数的参数是一个立即执行函数，也叫做立即执行器(excutor),这个立即执行函数有两个参数，这两个参数也是函数，分别是resolve和reject</strong></p><pre><code>resolve 函数的作用：将promise对象的状态从&quot;进行中&quot;改变成&quot;成功&quot;，在异步操作成功时调用，并将异步操作的结果作为参数传递除去,resolve(&quot;value&quot;)，这个值是任意值。reject  函数的作用：将promise对象的状态从&quot;进行中&quot;改变成&quot;失败&quot;，在异步操作失败时调用，并将异步操作的结果作为参数传递进去,reject(&quot;value&quot;)，这个值是任意值</code></pre><p><strong>promise三种状态</strong></p><pre><code>pending(进行中)resolved(成功)rejected(失败)promise状态只能由pending变成resolved，或者从pending变成rejected，不会从成功到失败也不会失败后再成功</code></pre><p>每一个Promise实例都有then方法，then方法是promise执行成功的函数，获取成功的结果，then可以多次被调用和链式调用,then调用之后返回的仍然是一个promise</p><pre><code>then(onFulfilled,onRejected)：第一个参数是获取成功的结果，第二个参数是获取失败的结果catch()：捕获失败的结果，通常把成功写在then()里面，把失败写在catch()里面finally()：无论成功失败都会执行的函数</code></pre><p><strong>promise方法</strong>   </p><pre><code>静态方法：方法挂载到构造函数身上动态方法：方法挂载到构造函数的原型下面</code></pre><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p><strong>Ajax原理的步骤</strong></p><ol><li>创建ajax对象</li><li>建立连接</li><li>发送请求</li><li>等待响应</li><li>解析数据</li></ol><p><strong>get和post的区别</strong></p><ol><li>从安全角度上：get方式相对不安全，传参时会暴露在url中，post相对安全</li><li>传数据大小上：get传参的大小约在4kb，post理论无限制</li><li>应用场景：<pre><code>     get主要用来获取数据也可发送数据，发送数据一般用来查询     post请求的多用于向服务器发送一些重要数据</code></pre></li><li>get请求缓存和编码问题</li><li>get请求发送参数拼接在url后面，post放在请求主体中</li></ol><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul><li> <strong>声明变量的方式</strong></li></ul><blockquote><p><strong>let</strong>：</p><ol><li>无变量提升</li><li>不可重复声明：不能声明同一个变量名，也不可在函数体内部声明参数</li><li>块级作用域：{}、if(){}、for(){}<br>用let声明的变量，只在let声明存在的代码块中生效</li></ol></blockquote><blockquote><p><strong>const</strong>：</p><ol><li>无变量提升</li><li>不可重复声明，一旦声明立即赋值，声明的是一个常量，不可修改</li><li>块级作用域：{}、if(){}、for(){}</li></ol></blockquote><blockquote><p><strong>var</strong>：</p><ol><li>变量提升；包含声明阶段和执行阶段</li><li>重复声明一个变量</li><li>只存在全局作用域和函数作用域<br>针对以上问题es6(ECMA2015)做了更新</li></ol></blockquote><ul><li><strong>模板字符串</strong></li></ul><p><strong>模板字符串用反引号定义</strong></p><pre><code>1. 像普通字符串使用2. 嵌入js表达式、变量里面，通过`$&#123;&#125;`的方式3. 可写多行字符串，不受回车、空格影响</code></pre><ul><li><strong>箭头函数</strong></li></ul><p><strong>箭头函数的特点</strong></p><p>优点：</p><pre><code>1. 书写简洁2. 不绑定this(没有this)，捕获上下文的this作为自己的this,继承作用域的this</code></pre><p>利用上述特点解决了问题</p><pre><code>1. 解决匿名函数this指向的问题2. 解决了setInterval  setTimeout中this的问题</code></pre><ul><li><strong>解构函数</strong></li></ul><p>解构赋值：</p><pre><code>es6允许按照某种模式，从数组或者对象中提取值，提取的值赋值给变量，这个过程称为解构赋值</code></pre><p>解构赋值的作用</p><pre><code>1. 可以交换变量，原理：数组解构赋值2. 可以提取json数据，原理：对象解构数据3. 函数返回多个值4. 给函数参数默认值，防止报错或找不到数据</code></pre><h2 id="target、currenttarget的区别"><a href="#target、currenttarget的区别" class="headerlink" title="target、currenttarget的区别"></a>target、currenttarget的区别</h2><pre><code>target当前被点击的元素currenttarget当前所绑定事件的元素</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>当内部函数保存到外部时，将会产生闭包 ，闭包将会导致原有作用域链不释放，造成内部泄露</strong></p><p>作用：</p><pre><code>1. 实现公有变量 函数累加器2. 可以做缓存（存储结构）防止3. 可以实现封装，属性私有化4. 模块化开发，污染全局变量。</code></pre><h2 id="Css水平垂直居中的方法"><a href="#Css水平垂直居中的方法" class="headerlink" title="Css水平垂直居中的方法"></a>Css水平垂直居中的方法</h2><p><strong>参考</strong></p><ul><li>⭐<a href="https://www.gjiayu.com/2021/06/14/%E5%B7%A5%E4%BD%9C%E5%AE%A4%E7%AC%94%E8%AF%95%E9%A2%98/">笔试题</a></li></ul><h2 id="怎么画一条0-5px的直线"><a href="#怎么画一条0-5px的直线" class="headerlink" title="怎么画一条0.5px的直线"></a>怎么画一条0.5px的直线</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height:1px;</span><br><span class="line">transform:scale(<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clear:both;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">::after</span><br></pre></td></tr></table></figure><h2 id="说一下label标签作用"><a href="#说一下label标签作用" class="headerlink" title="说一下label标签作用"></a>说一下label标签作用</h2><pre><code>label标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户体验</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><pre><code>通过函数产生一个独特的东西 作用域属于函数 函数产生于作用域</code></pre><h2 id="addEventListner-和-addchEvent区别"><a href="#addEventListner-和-addchEvent区别" class="headerlink" title="addEventListner 和 addchEvent区别"></a>addEventListner 和 addchEvent区别</h2><ol><li><p>参数不同</p><p> addEventListner（3）<br> addchEvent（2）</p></li><li><p>事件类型不同</p><p> addEventListner（不带on）<br> addchEvent（带on）</p></li><li><p>游览器支持不同</p><p> addEventListner（火狐谷歌支持 IE8不支持 IE11支持）<br> addchEvent（火狐谷歌不支持 IE8支持 IE11不支持）</p></li><li><p>this指向不同</p><p> addEventListner（this指向当前对象）<br> addchEvent（this指向window)</p></li></ol><h2 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><p><strong>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</strong><br><strong>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</strong><br><strong>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</strong></p><p>存储大小：</p><pre><code>cookie数据大小不能超过4k。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</code></pre><p>有期时间：</p><pre><code>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage  数据在当前浏览器窗口关闭后自动删除。cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</code></pre><h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><pre><code>做跨域请求的，ajax被同源策略限制 jsonp可以解决跨域问题</code></pre><p><strong>同源策略</strong></p><pre><code>游览器的安全机制，防止其他网站攻击导致信息泄露，或向网站请求资源，自己泄露</code></pre><p><strong>同源</strong></p><pre><code>协议，域名，端口号必须完全相同，有一个不同就是非同源</code></pre><p><strong>原理</strong></p><pre><code>动态创建script标签，利用她的src属性没有同源策略的限制，像请求地址发送一个get请求，预先定义一个函数，用来接收返回的数据，并要把这个函数名通过url携带参数的方式发送给服务器，服务器拿到这个函数名，它包裹着服务器返回的数据，服务器返回的函数的调用</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><pre><code>所谓节流就是指连续出发时间但是在n秒中只执行一次函数</code></pre><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><pre><code>防抖就是指触发事件后在n秒内函数只能执行一次，如果在n秒内又出发了时间，则会冲重新计算函数执行时间</code></pre><h2 id="js返回的typeof类型"><a href="#js返回的typeof类型" class="headerlink" title="js返回的typeof类型"></a>js返回的typeof类型</h2><pre><code>string、boolean、number、undefined、function、object</code></pre><h2 id="js强制类型转换和隐式类型转换"><a href="#js强制类型转换和隐式类型转换" class="headerlink" title="js强制类型转换和隐式类型转换"></a>js强制类型转换和隐式类型转换</h2><pre><code>parselnt、parseFloat、number隐式：===、==</code></pre><h2 id="split-join"><a href="#split-join" class="headerlink" title="split().join()."></a>split().join().</h2><pre><code>split() 将字符串切割成数组join() 数组转化为字符串pop() 尾部删除push() 尾部添加shift() 头部删除unshift() 头部添加</code></pre><h2 id="ajax请求时如何解析json数据"><a href="#ajax请求时如何解析json数据" class="headerlink" title="ajax请求时如何解析json数据"></a>ajax请求时如何解析json数据</h2><pre><code>JSON.Parse</code></pre><h2 id="和-区别"><a href="#和-区别" class="headerlink" title="==和===区别"></a>==和===区别</h2><pre><code>== 只判断值=== 判断值和数据类型</code></pre>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作室笔试题</title>
      <link href="/2021/06/14/%E5%B7%A5%E4%BD%9C%E5%AE%A4%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2021/06/14/%E5%B7%A5%E4%BD%9C%E5%AE%A4%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="输出100以内的素数"><a href="#输出100以内的素数" class="headerlink" title="输出100以内的素数"></a>输出100以内的素数</h2><p><strong>素数一般指质数， 质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。如2,3,5,7,11,17等</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">// 质数数组</span></span><br><span class="line">        <span class="keyword">var</span> zhishuArr=[];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 余数为0,整除的次数</span></span><br><span class="line">           <span class="keyword">var</span> count=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">                   count++</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="comment">//    是质数的话 i%j 只有两次是整除的， 余数为0</span></span><br><span class="line">           <span class="keyword">if</span>(count==<span class="number">2</span>)&#123;</span><br><span class="line">               zhishuArr.push(i);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;1-100以内的质数为:\n\n&quot;</span>+zhishuArr);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="封装一个方法"><a href="#封装一个方法" class="headerlink" title="封装一个方法"></a>封装一个方法</h2><p><strong>获取数组元素的最大值，如[2,8,15,1,5].max()的结果是15封装一个方法， 获取数组元素的最大值，如[2,8,15,1,5].max()的结果是15</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="built_in">Math</span>.max(<span class="number">2</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">98</span>, <span class="number">56</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(n);</span><br></pre></td></tr></table></figure><h2 id="隐藏网页中的元素有几种方式-这些方法有什么区别"><a href="#隐藏网页中的元素有几种方式-这些方法有什么区别" class="headerlink" title="隐藏网页中的元素有几种方式?这些方法有什么区别?"></a>隐藏网页中的元素有几种方式?这些方法有什么区别?</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.class&#123;</span><br><span class="line">    <span class="comment">/* 元素在页面彻底消失 */</span></span><br><span class="line">    display: none;</span><br><span class="line">    <span class="comment">/* 修改透明度为0 */</span></span><br><span class="line">    opacity: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 背景为透明 */</span></span><br><span class="line">    background: transparent;</span><br><span class="line">    <span class="comment">/* 元素在页面消失后，其占据的空间依旧会保留着 */</span></span><br><span class="line">    visibility:hidden</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有两个div-外框和内宽高度宽度都不定，内宽垂直水平居中，利用css如何实现"><a href="#有两个div-外框和内宽高度宽度都不定，内宽垂直水平居中，利用css如何实现" class="headerlink" title="有两个div,外框和内宽高度宽度都不定，内宽垂直水平居中，利用css如何实现?"></a>有两个div,外框和内宽高度宽度都不定，内宽垂直水平居中，利用css如何实现?</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    <span class="comment">/* 父组件利用flex的布局 */</span></span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何更新组件的state数据状态，如何实现当前state中page值累加"><a href="#如何更新组件的state数据状态，如何实现当前state中page值累加" class="headerlink" title="如何更新组件的state数据状态，如何实现当前state中page值累加?"></a>如何更新组件的state数据状态，如何实现当前state中page值累加?</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123; </span><br><span class="line">    page:state.page++ </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="react中props的使用场最有哪些，写出4种及以上-除了props还可以使用什么方法实现数据传递，怎么实现"><a href="#react中props的使用场最有哪些，写出4种及以上-除了props还可以使用什么方法实现数据传递，怎么实现" class="headerlink" title="react中props的使用场最有哪些，写出4种及以上? 除了props还可以使用什么方法实现数据传递，怎么实现?"></a>react中props的使用场最有哪些，写出4种及以上? 除了props还可以使用什么方法实现数据传递，怎么实现?</h2><ol><li>直接使用它的数据类型(父传子)</li><li>props.children 接收父组件(闭合组件)传入的数据</li><li>子传父用callback函数</li><li>props接收组件</li></ol><p><strong>除了props还可以使用context,mobx,redux方法实现数据传递；</strong></p><ol><li>先创建共享的上下文对象，</li><li>根组件用context.Provider作上下文组件数据提供者</li><li>数据的使用者用context.Consumer接收，Consumer里面必须是一个带返回值的函数</li></ol><h2 id="红绿灯问题"><a href="#红绿灯问题" class="headerlink" title="红绿灯问题"></a>红绿灯问题</h2><p><strong>假设已经有三个函数，red ,yellow, green,各代表红灯——亮3秒， 黄灯——亮1秒， 绿灯——亮2秒， 如何利用已有函数和Promise写法写一段代码，使红黄绿能一直往复交替亮下去?</strong></p><blockquote><p>style使用纯Css3的animation实现</p></blockquote><p>Css写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">        #light &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            animation: hld 6s ease infinite</span><br><span class="line">        &#125;</span><br><span class="line">         @keyFrames hld &#123;</span><br><span class="line">            <span class="number">0</span>% &#123;</span><br><span class="line">                background: green</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="number">50</span>% &#123;</span><br><span class="line">                background: yellow</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="number">67</span>% &#123;</span><br><span class="line">                background: red</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>html写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;light&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="描述var-let-const的特点"><a href="#描述var-let-const的特点" class="headerlink" title="描述var/let/const的特点"></a>描述var/let/const的特点</h2><p><strong>let</strong></p><ol><li>无变量提升</li><li>不可重复声明：不能声明同一个变量名，也不可在函数体内部声明参数</li><li>块级作用域：{}、if(){}、for(){}</li></ol><p>用let声明的变量，只在let声明存在的代码块中生效</p><p><strong>const</strong></p><ol><li>无变量提升</li><li>不可重复声明，一旦声明立即赋值，声明的是一个常量，不可修改</li><li>块级作用域：{}、if(){}、for(){}</li></ol><p><strong>var</strong></p><ol><li>变量提升；包含声明阶段和执行阶段</li><li>重复声明一个变量</li><li>只存在全局作用域和函数作用域</li></ol><h2 id="vue-router传参方式有哪几种"><a href="#vue-router传参方式有哪几种" class="headerlink" title="vue-router传参方式有哪几种?"></a>vue-router传参方式有哪几种?</h2><ol><li>query传参</li><li>params显式和隐式传参</li></ol><h2 id="vue响应式底层原理是什么"><a href="#vue响应式底层原理是什么" class="headerlink" title="vue响应式底层原理是什么?"></a>vue响应式底层原理是什么?</h2><p>object.defineProperty</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节流、防抖、闭包</title>
      <link href="/2021/06/14/%E8%8A%82%E6%B5%81%E3%80%81%E9%98%B2%E6%8A%96%E3%80%81%E9%97%AD%E5%8C%85/"/>
      <url>/2021/06/14/%E8%8A%82%E6%B5%81%E3%80%81%E9%98%B2%E6%8A%96%E3%80%81%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h3><p>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。<br>节流点击按钮，设置三秒以后才可以点击下一次，在这三秒时间内无论点击多少次都不会触发函数，只有当到达三秒钟后才会继续触发函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">cd,wait</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//第一次执行的时间</span></span><br><span class="line">    <span class="keyword">let</span> first = <span class="number">0</span></span><br><span class="line">    <span class="comment">//this指针改变，需要存this</span></span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">if</span>(now - first &gt; wait)&#123;</span><br><span class="line">            first = now</span><br><span class="line">            cd.apply(that,argument)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.elementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>,throttle(fn,<span class="number">3000</span>),<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="防抖debounce"><a href="#防抖debounce" class="headerlink" title="防抖debounce"></a>防抖debounce</h3><p>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。<br>防抖：过滤掉输入过程中无意义的响应，只需要设置一个定时器，并在定时器启动后执行这个回调函数；若在定时器启动前又有相同回调到来，便取消之前的定时器（clearTimeout）——之前的回调便取消了；然后再创一个新的定时器回调，如此反复。<br>//防抖   点击按钮，在一定时间内继续执行按钮则不执行事件，最后一次点击执行事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果在2秒内点击按钮，则清除上次定时器，重新开始计时</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(that, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, debounce(fn, <span class="number">2000</span>), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>能够访问另一个函数作用域的变量的函数<br>当内部函数保存到外部时，将会产生闭包 ，闭包将会导致原有作用域链不释放，造成内部泄露<br>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境。<br>return一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> a();</span><br><span class="line">demo();<span class="comment">//101</span></span><br><span class="line">demo();<span class="comment">//102</span></span><br></pre></td></tr></table></figure><blockquote><p>作用</p></blockquote><ol><li>实现公有变量，函数累加器</li><li>可以做缓存</li><li>可以实现封装，属性私有化</li><li>模板化开发，防止污染全局变量</li></ol><blockquote><p>闭包特性</p></blockquote><ol><li>函数嵌套函数</li><li>函数内部可以引用函数外部的参数和变量</li><li>参数和变量不回被垃圾回收机制回收</li></ol><blockquote><p>闭包好处</p></blockquote><ol><li>保护函数内的变量的安全，实现封装，防止变量流入其他环境发生命名冲突</li><li>在内存中维持一个变量，可以做缓存</li><li>匿名自执行函数可以减少内存消耗</li></ol><blockquote><p>闭包坏处</p></blockquote><ol><li>被引用的私有变量不能被销毁，增大内存消耗，造成内存泄漏，解决方法就是可以在使用完变量后手动为他复制null</li><li>其次由于闭包设计跨域问题，所以导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻执行速度影响</li></ol>]]></content>
      
      
      <categories>
          
          <category> 节流/防抖/闭包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 节流/防抖/闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html和Css</title>
      <link href="/2021/06/10/Html%E5%92%8CCss/"/>
      <url>/2021/06/10/Html%E5%92%8CCss/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>HTML 结构<br>css 风格样式<br>JavaScript  花里胡哨</p><p>HTML4.0+CSS2用于pc端<br>HTML5+CSS3用于客户端</p><ul><li>CSS  (Cascading Style Sheet)层叠样式表</li></ul><ul><li>HTML(Hyper Text Markup Language)超文本标记语言</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;                                                          charset     char 字符   set设置</span><br><span class="line"> &lt;meta charset=<span class="string">&quot;utf-8&quot;</span> /&gt;        utf-<span class="number">8</span> 万国码    解决乱码问题</span><br><span class="line">                                 &lt;title&gt;&lt;/title&gt;</span><br><span class="line">                  &lt;/head&gt;</span><br><span class="line">                  &lt;body&gt;</span><br><span class="line">                  &lt;/body&gt;  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>html：  超文本语言 Hyper Text Markup Language</li></ul><ul><li>css：     层叠样式表 Cascading Style Sheet</li></ul><ul><li>url：      统一资源定位符（通俗的指链接地址）Uniform Resource Locater</li></ul><ul><li>w3c：   万维网联盟  World Wide Web</li></ul><blockquote><p><strong>所有标签在html里可以设置宽高</strong></p></blockquote><ul><li>title是标题   </li><li>&lt;&gt;是尖括弧</li><li><h1-h6>都是文字标题标签</li><li><p> 段落标签</li><li><code>&lt;a 超链接属性 必须属性：href=&quot;跳转地址&quot;&gt;</code><br><code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;</code><br> a标签属性：            <code>target=“ blank”</code><br> <code>target </code>               超链接跳转方式控制页面打开<br> <code>_blank空白页</code>          新页面打开<br> <code>_self</code>                 在当前页面打开（默认）<br> <code>title</code>                      鼠标滑过加提示信息0<br>  <code># </code>                     刷新页面</li></ul><p>锚标记：<br><code>&lt;a href=&quot;#&quot; name=&quot;&quot;&gt;1&lt;/a&gt;</code><br><code>&lt;a href=&quot;#&quot; name=&quot;&quot;&gt;2&lt;/a&gt;</code>    点击1跳到2</p><ul><li><p><code>&lt;img /&gt; 图片标签 必须属性：src=&quot;img/图片地址&quot;  用法：*&lt;img  src=“img/图片地址”/&gt;</code></p><p>  <code> title</code> 鼠标滑过图片提示信息<br>  <code>alt</code>   图片加载失败文字提示</p></li><li><p><code>&lt;br/&gt;</code>  强制换行 </p></li><li><p><code>&lt;hr size=&quot;&quot; color=&quot;&quot;/&gt;</code>水平分割线</p></li></ul><p>属性:   </p><pre><code>1. width  设置宽度 用法`&lt;hr width=&quot;10&quot;/&gt;`2. color   颜色 用法`&lt;hr color=&quot;blue&quot;/&gt;`3. align   居中方式   用法`&lt;hr align=&quot;left/right/center&quot;/&gt;`4. size     大小粗细 数越大越粗  用法`&lt;hr size=&quot;3px&quot;/&gt;` </code></pre><ul><li><p><code>&lt;span&gt;</code>                      文字标签 给字体加样式</p></li><li><p><code>&lt;font &gt;&lt;/font&gt;</code>      字体颜色 用法： <code>&lt;font color=&quot;blue&quot;&gt;&lt;/font&gt;</code></p></li><li><p><code>&lt;b&gt;&lt;/b&gt; </code><br><code>&lt;strong&gt;&lt;/strong&gt;</code>文字加粗标签<br> <code>font-weight: bold;</code></p></li><li><p><code>&lt;em&gt;&lt;/em&gt;</code><br><code>&lt;i&gt;&lt;/i&gt;</code><br> <code>font-style: italic;</code>                文字倾斜标签(3个)</p></li><li><p><code>&lt;u&gt;&lt;/u&gt;</code><br><code>text-decoration：underline;</code> 下划线</p></li><li><p><code>&lt;s&gt;&lt;/s&gt;strike</code><br><code>text-align：line-through</code>   删除线</p></li><li><p>标签属性：</p><pre><code>      `align=&quot;center&quot;` 文字/图片居中   用法：`&lt;p align=&quot;center&quot;&gt;&lt;/p&gt;`      `left`  靠左      `right` 靠右      `center`  居中</code></pre></li><li><p>注释信息<code>&lt;!--  --&gt; </code> 在页面不显示/注释/隐藏，快捷键<code>shift</code>状态下  <code>ctrl+/</code></p></li></ul><p><code>frameset</code>框架型</p><hr><ul><li><p>网站导航条</p></li><li><p><code>ul  (unorderd list)</code>无序列表   每项是li      用法：  <code>&lt;ul&gt;&lt;li&gt;      &lt;/li&gt;&lt;/ul&gt;</code><br><code>ol（orderd list）</code>      有序列表   每项是li      用法：   <code>&lt;ol&gt;&lt;li&gt;      &lt;/li&gt;&lt;/ol&gt;</code><br><code>dl（definition list）</code> 自定义列表</p></li><li><p>ul去点：在<code>style</code>里输入  <code>&#123;list-style:none&#125;</code><br>清楚列表样式          <code>ul&#123;list-style: none;&#125;</code></p><p>黑点变图片：<br><code>list-style-image：url（）；</code><br><code>list-style-type: ;</code></p><p>列表样式：               1.实心圆：<code>disc</code></p><pre><code>                  2.空心圆：`circle`                  3.方块：`square`</code></pre></li><li><p>横向排列（浮动）   <code>float：left</code></p><p>  <code>ul</code> <code>ol</code>  <code>dl—li</code><br>  css样式 使用ul组合样式浮动<code>float：left/right；</code><br>  浮动出现问题的解决方式：<br>  1.设置好整个父级的宽高 解决80%的问题<br>  2.<code>clear：both；</code>（清除浮动）</p></li></ul><p><code>definition</code> 自定义<br><code>attribute</code> 属性</p><hr><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><blockquote><p><strong>选择器：利用样式优先级</strong></p></blockquote><ol><li><p>标签选择器：配合使用  缺点：会被覆盖  div{ width: ;height: ;}</p></li><li><p>类名选择器：用class命名，.box{ }</p></li><li><p>ID选择器：标签后面id=“id名称” 调用：#id名称。<code>&lt;p id=&quot;name&quot;&gt;#name</code></p><pre><code>                 id名称是唯一的 不能重复用一个名字，id可以是多个，id的优先级比类名高 </code></pre></li><li><p>通用选择器：*{ margin：0；padding：0}或者控制字体   控制网页全局样式</p></li><li><p>伪类选择器：hover：鼠标滑过时的样式  .box： :hover{ }</p><pre><code>                 active：鼠标点击时的样式                 before/after   </code></pre></li><li><p>子代选择器：两代  .box p{ }</p></li><li><p>后代选择器：三级及以上</p></li><li><p>群组选择器：多个标签一起设置 div,p,ul,li，body,span{ }</p></li><li><p>交叉选择器：两个不同选择器一起设置 .box p{ }</p></li></ol><p><strong>优先级：ID选择器&gt;类名选择器&gt;标签选择器</strong></p>]]></content>
      
      
      <categories>
          
          <category> Html/Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html/css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2021/06/10/JavaScript/"/>
      <url>/2021/06/10/JavaScript/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么叫Java-Script？"><a href="#什么叫Java-Script？" class="headerlink" title="什么叫Java Script？"></a>什么叫Java Script？</h2><ol><li>解释型语言<br> js引擎解析<br> 编译语言：代码写完后还要编译成计算机识别的语言才可以执行，计算机只识别0和1</li><li>单线程<br> 代码从上往下执行，如果中间出现了阻塞，代码会停在当前位置</li><li>脚本语言<br> 无需编译，把代码放到浏览器由JS引擎解析并执行</li><li>弱类型<br> 所有变量声明都用var<br> 强类型：int(数值)、char、string、float、double、long</li><li>一门基于对象的语言 – 模拟面向对象的思想<br> 因为没有类的概念，所以没有多态的特征，所以是一门基于对象的语言<br> 面向对象的条件：继承，封装，多态（类与类之间的关系）</li><li>是一门动态类型的语言<br> 代码解析到指定位置才知道该变量存储的数据类型<br> 点语法：没有什么 点什么 就有了</li></ol><h2 id="前后端区别"><a href="#前后端区别" class="headerlink" title="前后端区别"></a>前后端区别</h2><ol><li>前端：代码运行在浏览器上 （客户）<br>             Html(结构)、Css(样式)、JS(脚本语言、动作)</li><li>后端：代码运行在服务器上（公司） <br>              C、C++、C#、PHP、Java</li></ol><h2 id="JS语言特点"><a href="#JS语言特点" class="headerlink" title="JS语言特点"></a>JS语言特点</h2><ol><li>编译性语言：通篇编译再读取<br> 例：C（母语）、C++<br> 优点：速度快    不足：移植性不好</li><li>解释性语言：解释一行读一行<br> 例：JS、PHP<br> 优点：跨平台     不足：速度稍慢</li></ol><h2 id="JS语言"><a href="#JS语言" class="headerlink" title="JS语言"></a>JS语言</h2><p> <br>同步：同时只做一件事<br>异步：同时可以做很多事（link/img/script/src）（http请求线程，浏览器定时触发器，浏览器事件触发线程）<br>单线程：DOM（同时只做一件事、同步）<br>多线程：浏览器、Node</p><h2 id="JS的组成部分"><a href="#JS的组成部分" class="headerlink" title="JS的组成部分"></a>JS的组成部分</h2><ol><li>ECMAscript：描述了该语言的语法和基本对象<br> ECMA:European Computer Manufacturers Association欧洲计算机制造商协会</li><li>DOM文档对象模型（属於BOM）：描述处理网页内容的方法和接口<br> Document Object Model</li><li>BOM浏览器对象模型：描述与浏览器进行交互的方法和接口<br> Browser(浏览器) Object Model</li></ol><h2 id="五大浏览器及其内核"><a href="#五大浏览器及其内核" class="headerlink" title="五大浏览器及其内核"></a>五大浏览器及其内核</h2><p>浏览器:      内核<br><code>IE</code>：          <code>Trident</code><br><code>Chrome</code>：      <code>Webkit</code><br><code>Safari</code>：      <code>Webkit</code><br><code>Firefox</code> ：    <code>Gecko</code><br><code>Opera</code> ：      <code>Presto</code></p><p><em>现在Chrome和Opera用的是Blink内核</em><br><strong>主流浏览器的特点？</strong><br>1.3%及以上市场占有率<br>2.有自己独立的内核</p><h2 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h2><ol><li>只能使用字母或者下划线开头，变量名主体只能使用数字、字母、下划线</li><li>变量的名字要具备语义化命名（userName-&gt;用户名）<br> <code>userName</code> 驼峰命名<br> <code>UserName</code> 大驼峰命名</li><li>不可以使用系统关键字命名</li></ol><h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><ul><li>基本数据类型/原始数据类型/值类型：number、string、boolean、null、undefined</li><li>引用数据类型：Array、Object、function</li></ul><p><strong>基本数据类型与原始数据类型的区别？</strong></p><p>存储的位置不同，基本数据类型存放于栈(heap)，引用数据类型存放于堆(stack)</p><h2 id="是否添加分隔符"><a href="#是否添加分隔符" class="headerlink" title="是否添加分隔符"></a>是否添加分隔符</h2><ol><li>应该加但没加不报错<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a,b,c,d</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure></li><li>不需要加<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">num</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">for</span>()&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>必须加<br> 在 <code>[ ]</code>、<code>反引号</code>、<code>()</code> 前必须加</li></ol><h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><p><strong>一、运算操作符</strong></p><ol><li>加号：数字与数字之间是数学运算<pre><code>      做字符串拼接(任何数据类型与字符拼接都会得到字符串)</code></pre></li></ol><ul><li>不建议大量拼接字符串，会导致内存溢出，字符串的任何方法都不会改变原字符串，而是创建新字符串，拼接字符串也不例外<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span> +<span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc&#x27;</span>+<span class="string">&#x27;bcd&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc&#x27;</span>+<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(str));</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc&#x27;</span>+[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abc&#x27;</span>+<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="literal">true</span>=<span class="number">1</span>，<span class="literal">false</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>减法</li><li>乘法</li><li>除法：<br>例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span> / <span class="number">2</span> ;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a= <span class="number">0</span>/<span class="number">0</span>；</span><br><span class="line"><span class="built_in">console</span>.log(a);=<span class="literal">NaN</span>(o做除数无论被除数是谁结果都是<span class="literal">NaN</span>)</span><br><span class="line"><span class="literal">NaN</span>:not a number(非数)属於number</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>/<span class="number">0</span>；</span><br><span class="line"><span class="built_in">console</span>.log(a);=infinity</span><br><span class="line"><span class="keyword">var</span> a = -<span class="number">1</span>/<span class="number">0</span>；</span><br><span class="line"><span class="built_in">console</span>.log(a);= -infinity</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>/<span class="number">1</span>；</span><br><span class="line"><span class="built_in">console</span>.log(a);=<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li>% 取模 （取余）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>%<span class="number">3</span> =<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li>++累加/加加<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>；</span><br><span class="line">a++；</span><br><span class="line">a++；</span><br><span class="line"><span class="built_in">console</span>.log(a);=<span class="number">11</span></span><br></pre></td></tr></table></figure></li><li>–累减<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>；</span><br><span class="line">a--；</span><br><span class="line"><span class="built_in">console</span>.log(a);=<span class="number">9</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>a++、 a–先给值后运算</li><li>++a、–a 先运算再给值</li></ul><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">var</span> b = a++ + a;</span><br><span class="line"><span class="built_in">console</span>.log(b);=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">var</span> b = a++ + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a-- - --a;</span><br><span class="line"><span class="built_in">console</span>.log(b);=<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ol><li>+=加等<br>例子：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>；</span><br><span class="line">a += <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></li><li>-= 减等<br>例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">a = a + b;a=<span class="number">30</span> b=<span class="number">20</span></span><br><span class="line">b = a - b;a=<span class="number">30</span>  b=<span class="number">10</span></span><br><span class="line">a = a - b;a=<span class="number">20</span>  b=<span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br></pre></td></tr></table></figure></li><li>*=乘等</li><li>/=除等</li><li>%=</li></ol>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React</title>
      <link href="/2021/06/09/React/"/>
      <url>/2021/06/09/React/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="react-是单项数据流，如何实现数据双向绑定"><a href="#react-是单项数据流，如何实现数据双向绑定" class="headerlink" title="react 是单项数据流，如何实现数据双向绑定"></a>react 是单项数据流，如何实现数据双向绑定</h3><p>用 <code>onChange</code> 事件，通过 <code>setstate</code> 来设置 <code>state</code>值</p><h3 id="react-中事件-this-绑定的实现方法有哪些"><a href="#react-中事件-this-绑定的实现方法有哪些" class="headerlink" title="react 中事件 this 绑定的实现方法有哪些"></a>react 中事件 this 绑定的实现方法有哪些</h3><p><code>es6</code> 箭头函数<br>在 <code>constructor</code> 中绑定 <code>this</code><br>调用时以箭头函数 <code>onClick= &#123;(e)=&gt;this.fn(e)&#125;</code><br>在调用时直接绑定 <code>this onclick=&#123;this.fn.bind(this)&#125;</code></p><h3 id="react-组件的几种写法，分别是什么"><a href="#react-组件的几种写法，分别是什么" class="headerlink" title="react 组件的几种写法，分别是什么"></a>react 组件的几种写法，分别是什么</h3><p>函数形式<code>（es5,es6）</code><br>类组件 函数组件是以参数来接收 <code>props </code>类组件是<code> this.props</code><br>ES5-写法 <code>React.createClass</code>（不推荐）<br>ES6-写法 <code>React.Component</code>（有状态组件可以用）<br>无状态的函数式写法（纯组件 SFC,推荐）</p><h3 id="es6-的知识点"><a href="#es6-的知识点" class="headerlink" title="es6 的知识点"></a>es6 的知识点</h3><p><code>let、 const、 map、... 、解构、 箭头函数、 class、export、 import、模板字符串、get set、as fault</code></p><h3 id="vue-react-打包的项目自定义路由，是否可以正常使用"><a href="#vue-react-打包的项目自定义路由，是否可以正常使用" class="headerlink" title="vue react 打包的项目自定义路由，是否可以正常使用"></a>vue react 打包的项目自定义路由，是否可以正常使用</h3><p><code>nginx url</code> 重写</p><p>location /{<br>try_files $uri /index.html;<br>index index.html index.htm index.php;<br>}</p><h3 id="js-中会使用-return，false-来阻止默认事件，react-有合成事件想阻止默认事件，事件冒泡怎么做"><a href="#js-中会使用-return，false-来阻止默认事件，react-有合成事件想阻止默认事件，事件冒泡怎么做" class="headerlink" title="js 中会使用 return，false 来阻止默认事件，react 有合成事件想阻止默认事件，事件冒泡怎么做"></a>js 中会使用 return，false 来阻止默认事件，react 有合成事件想阻止默认事件，事件冒泡怎么做</h3><p>阻止默认事件：a 标签里面写 true <code>e.preventDefault()</code><br>阻止事件冒泡：<code>e.stopPropagation()</code></p><p>a 标签 input 添加事件 阻止默认事件</p><h3 id="在-react-开发中会涉及到多个组件的交互操作，如果当前组件有-ajax-请求未完成，这时直接跳到另一个组件会报错，我们如何来阻止报错"><a href="#在-react-开发中会涉及到多个组件的交互操作，如果当前组件有-ajax-请求未完成，这时直接跳到另一个组件会报错，我们如何来阻止报错" class="headerlink" title="在 react 开发中会涉及到多个组件的交互操作，如果当前组件有 ajax 请求未完成，这时直接跳到另一个组件会报错，我们如何来阻止报错"></a>在 react 开发中会涉及到多个组件的交互操作，如果当前组件有 ajax 请求未完成，这时直接跳到另一个组件会报错，我们如何来阻止报错</h3><p><code>componentWillUnmount（取消 ajax 请求）</code></p><h3 id="react-组件的生命周期的阶段是什么，常用生命周期的方法有哪些"><a href="#react-组件的生命周期的阶段是什么，常用生命周期的方法有哪些" class="headerlink" title="react 组件的生命周期的阶段是什么，常用生命周期的方法有哪些"></a>react 组件的生命周期的阶段是什么，常用生命周期的方法有哪些</h3><p>一、挂载<br>1、<code>constructor()</code>   挂载前：初始化 <code>state</code>  和为事件处理函数绑定实例<br>2、<code>DidMount()</code>  挂载后：（插入  <code>DOM</code>  树中）立即调用，定时器，请求、对应 <code>WillUnmount()</code><br>二、更新<br>1、<code>render()</code> <code>props</code>  和 <code>state</code>  变化   时<br>2、<code>componentDidUpdate()</code>  组件更新时调用<br>三、卸载   当组件从  <code>DOM </code> 中移除(组件卸载及销毁之前)时会调用<br>1、<code>componentWillUnmount()</code><br>清定时器、取消 <code>ajax</code> 请求，对应 <code>DidMount()</code></p><h3 id="写出常见的-props-三种以上的应用场景"><a href="#写出常见的-props-三种以上的应用场景" class="headerlink" title="写出常见的 props 三种以上的应用场景"></a>写出常见的 props 三种以上的应用场景</h3><p>除了 <code>props</code> 进行父子通信还能使用 <code>content</code><br>1、简单的接收父组件传递的字符串形式(数据类型)<br>2、<code>children</code><br>子组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;child&quot;</span>&gt;标题&#123;<span class="built_in">this</span>.props.children&#125;&lt;/div&gt;</span><br><span class="line">父组件</span><br><span class="line">&lt;Child&gt;</span><br><span class="line">    &lt;span&gt;副标题&lt;/span&gt;</span><br><span class="line">&lt;/Child&gt;</span><br></pre></td></tr></table></figure><p>3、比如子组件是左侧导航</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">子组件</span><br><span class="line">&lt;div className=<span class="string">&quot;fx_left&quot;</span>&gt;ul ol&lt;/div&gt;</span><br><span class="line">父组件</span><br><span class="line">&lt;Child left=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Ul</span>/&gt;</span></span>&#125;&gt;</span><br><span class="line">父组件</span><br><span class="line">&lt;Child left=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Ol</span>/&gt;</span></span>&#125;&gt;</span><br><span class="line">&lt;Child left=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Dl</span>/&gt;</span></span>&#125;&gt;</span><br></pre></td></tr></table></figure><p>4、callback<br>子组件需要把当前组件的数据返回给父组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">父组件</span><br><span class="line">&lt;Child aaa=&#123;<span class="built_in">this</span>.clback.bind(<span class="built_in">this</span>)&#125;&gt;</span><br><span class="line"><span class="function"><span class="title">clback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">子组件</span><br><span class="line"></span><br><span class="line">&lt;div onClick=&#123;<span class="function">(<span class="params">e</span>)=&gt;</span><span class="built_in">this</span>.parentFn(e)&#125;&gt;&lt;/div&gt;</span><br><span class="line"><span class="function"><span class="title">parentFn</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.props.aaa(e)</span><br><span class="line">&#125;</span><br><span class="line">事件A可以直接操作Fn函数</span><br><span class="line">事件A并不是父组件内的内容而是子组件的</span><br></pre></td></tr></table></figure><h3 id="已知对象-ajax，obj-返回一个后如何合并原有对象，使用至少两个方法实现"><a href="#已知对象-ajax，obj-返回一个后如何合并原有对象，使用至少两个方法实现" class="headerlink" title="已知对象 ajax，obj 返回一个后如何合并原有对象，使用至少两个方法实现"></a>已知对象 ajax，obj 返回一个后如何合并原有对象，使用至少两个方法实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.state=&#123;</span><br><span class="line">edu：&#123;</span><br><span class="line">name：“”，</span><br><span class="line">age：“”</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">edu:&#123;</span><br><span class="line">name:data.edu.name,</span><br><span class="line">age:data.edu.age</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="如何更新组件-state-数据状态"><a href="#如何更新组件-state-数据状态" class="headerlink" title="如何更新组件 state 数据状态"></a>如何更新组件 state 数据状态</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;&#125;);</span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="当前组件引入一个子组件，如何在子组件中获取到-data-的值，，并使用-es6-进行改写"><a href="#当前组件引入一个子组件，如何在子组件中获取到-data-的值，，并使用-es6-进行改写" class="headerlink" title=" 当前组件引入一个子组件，如何在子组件中获取到 data 的值，，并使用 es6 进行改写"></a><App data={data/}> 当前组件引入一个子组件，如何在子组件中获取到 data 的值，，并使用 es6 进行改写</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.props.data</span><br><span class="line">&lt;App &#123;...data&#125;/&gt;</span><br><span class="line"><span class="built_in">this</span>.props.name</span><br></pre></td></tr></table></figure><h3 id="如何将两个或多个组件嵌入到一个组件中"><a href="#如何将两个或多个组件嵌入到一个组件中" class="headerlink" title="如何将两个或多个组件嵌入到一个组件中"></a>如何将两个或多个组件嵌入到一个组件中</h3><p><code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code></p><p><code>&lt;div&gt;&lt;/div&gt;</code></p><h3 id="分别写-map-回调函数的两种形式"><a href="#分别写-map-回调函数的两种形式" class="headerlink" title="分别写 map 回调函数的两种形式"></a>分别写 map 回调函数的两种形式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map(<span class="function">(<span class="params">val,index</span>)=&gt;</span>(</span><br><span class="line"></span><br><span class="line">&lt;li key=&#123;&#125;&gt;&lt;/li&gt;</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">map(<span class="function">(<span class="params">val,index</span>)=&gt;</span>(&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="已有数组对象-object，要求通过点击事件向数组-arr-添加，并且每条展末数组可以轻松删除，使用-react-实现-19-子组件如何操作父组件"><a href="#已有数组对象-object，要求通过点击事件向数组-arr-添加，并且每条展末数组可以轻松删除，使用-react-实现-19-子组件如何操作父组件" class="headerlink" title="已有数组对象 object，要求通过点击事件向数组 arr 添加，并且每条展末数组可以轻松删除，使用 react 实现 19.子组件如何操作父组件"></a>已有数组对象 object，要求通过点击事件向数组 arr 添加，并且每条展末数组可以轻松删除，使用 react 实现 19.子组件如何操作父组件</h3><p><code>callback</code></p><h3 id="ut，type-为-password-时会自动填充，如何实现取消自动填充"><a href="#ut，type-为-password-时会自动填充，如何实现取消自动填充" class="headerlink" title="ut，type 为 password 时会自动填充，如何实现取消自动填充"></a>ut，type 为 password 时会自动填充，如何实现取消自动填充</h3><p><code>auto-complete=&quot;new-password&quot;</code></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端</title>
      <link href="/2021/06/03/%E5%90%8E%E7%AB%AF/"/>
      <url>/2021/06/03/%E5%90%8E%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>打开网址：<a href="https://blog.csdn.net/ychgyyn/article/details/84404217">https://blog.csdn.net/ychgyyn/article/details/84404217</a> 参考My SQL 安装流程</p></blockquote><blockquote><p>.打开网址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a> 安装第一个</p></blockquote><h2 id="下载完成后-在开始中打开文件进行配置"><a href="#下载完成后-在开始中打开文件进行配置" class="headerlink" title="下载完成后  在开始中打开文件进行配置"></a>下载完成后  在开始中打开文件进行配置</h2><p>在开始中——&gt;windows系统——&gt;右击命令提示符——&gt;更多——&gt;管理员身份运行——&gt;D:(切换到D盘)——&gt;cd MySQL——&gt;cd mysql-8.0.25-winx64——&gt;cd bin——&gt;mysqld –initialize –console ——&gt;mysqld -install——&gt;net start mysql——&gt;mysql -u root -p——&gt;alter user ‘root’@’localhost’ identified by ‘想要设置的密码’;——&gt;commit;——&gt;quit   退出数据库</p><blockquote><p>报错可通过桌面DirectX Repair文件进行修复。</p></blockquote><blockquote><p>安装Navicat for MySQL进行链接。</p></blockquote><h2 id="新建文件夹（egg）——-gt-使用git-Bash-here——-gt-快速生成项目"><a href="#新建文件夹（egg）——-gt-使用git-Bash-here——-gt-快速生成项目" class="headerlink" title="新建文件夹（egg）——&gt;使用git Bash here——&gt;快速生成项目"></a>新建文件夹（egg）——&gt;使用git Bash here——&gt;快速生成项目</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> mkdiregg-example&amp;&amp;cdegg-example （新建egg-example进入egg-example）</span><br><span class="line"></span><br><span class="line">npm init egg --type=simple  （初始化项目）</span><br><span class="line"></span><br><span class="line">npm run dev (启动命令)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="配置egg项目"><a href="#配置egg项目" class="headerlink" title="配置egg项目"></a>配置egg项目</h2><ol><li><p>打开egg项目</p></li><li><p>打开目录<code>config</code>下的<code>plugin.js</code>添加</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> mysql : &#123;                                                                                      </span><br><span class="line">    enable: <span class="literal">true</span>,</span><br><span class="line">    package: <span class="string">&#x27;egg-mysql&#x27;</span>,</span><br><span class="line">  &#125;      </span><br><span class="line"><span class="string">``</span><span class="string">`        </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. 打开目录`</span>config<span class="string">`下的`</span><span class="keyword">default</span>.js<span class="string">`的`</span><span class="built_in">module</span>.exports = appInfo<span class="string">`的箭头函数中添加</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">  config.mysql = &#123;</span><br><span class="line">    clients: &#123;</span><br><span class="line">      <span class="comment">// clientId, 获取client实例，需要通过 app.mysql.get(&#x27;clientId&#x27;) 获取</span></span><br><span class="line">      db1: &#123;</span><br><span class="line">        <span class="comment">// host</span></span><br><span class="line">        host: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="comment">// 端口号</span></span><br><span class="line">        port: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        user: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        password: <span class="string">&#x27;***&#x27;</span>,</span><br><span class="line">        <span class="comment">// 数据库名</span></span><br><span class="line">        database: <span class="string">&#x27;first-egg&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      db2: &#123;</span><br><span class="line">        <span class="comment">// host</span></span><br><span class="line">        host: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="comment">// 端口号</span></span><br><span class="line">        port: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        user: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">        <span class="comment">// 密码</span></span><br><span class="line">        password: <span class="string">&#x27;***&#x27;</span>,</span><br><span class="line">        <span class="comment">// 数据库名</span></span><br><span class="line">        database: <span class="string">&#x27;first-egg&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有数据库配置的默认值</span></span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 是否加载到 app 上，默认开启</span></span><br><span class="line">    app: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否加载到 agent 上，默认关闭</span></span><br><span class="line">    agent: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  config.security = &#123;</span><br><span class="line">    csrf: &#123;</span><br><span class="line">      enable: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>打开目录<code>controller</code>新建<code>users.js</code>添加代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Controller;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsersController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">index</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="built_in">this</span>.ctx.service.users.findAll(<span class="built_in">this</span>.ctx);</span><br><span class="line">    <span class="built_in">this</span>.ctx.body = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UsersController;</span><br></pre></td></tr></table></figure></li><li><p>新建文件夹<code>service</code>新建<code>users.js</code>文件添加代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/service/user.js</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).Service;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsersService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 查所有的</span></span><br><span class="line">    <span class="comment">// async findAll(ctx) &#123;</span></span><br><span class="line">    <span class="comment">//     const user = await this.ctx.service.users.findAll(&#x27;db1&#x27;).select(&#x27;users&#x27;);</span></span><br><span class="line">    <span class="comment">//     return &#123;user&#125;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">findAll</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="built_in">this</span>.app.mysql.get(<span class="string">&#x27;db1&#x27;</span>).select(<span class="string">&#x27;users&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;user&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UsersService;</span><br></pre></td></tr></table></figure></li><li><p>npm run dev在控制台打开此项目</p></li><li><p>打开Navicat for MySQL</p></li></ol><blockquote><p>1.新建项目egg  （通过密码为你设置的password）<br>2.新建文件first_my 并打开<br>3.新建表 添加<br> <code>id</code>  <code>name</code>  <code>age</code> <code>create_up</code> <code>update_up</code></p></blockquote><p>保存名为<code>users</code></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2021/05/30/HTML/"/>
      <url>/2021/05/30/HTML/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>Emmet</code>(前身为 <code>Zen Coding</code>) 是一个能大幅度提高前端开发效率的一个工具. 在前端开发的过程中，一大部分的工作是写 <code>HTML</code>、<code>CSS</code> 代码。特别是手动编写 <code>HTML</code> 代码的时候，效率会特别低下，因为需要敲打很多尖括号，而且很多标签都需要闭合标签等。于是，就有了 <code>Emmet</code>，它可以极大的提高代码编写的效率，它提供了一种非常简练的语法规则，然后立刻生成对应的 <code>HTML</code> 结构或者 <code>CSS</code> 代码，同时还有多种实用的功能帮助进行前端开发。</p><p><code>VsCode</code> 内置了 <code>Emmet </code>语法,在后缀为<code>.html/.css</code> 中输入缩写后按 <code>Tab</code> 键即会自动生成相应代码</p><p>请注意在 <code>VsCode</code> 新版本中按 <code>Tab</code> 不再默认启用 <code>Emmet</code> 展开缩写!需要在首选项配置中设置为 <code>emmet.triggerExpansionOnTab:true!</code></p><p>语法基本规则如下:</p><table><thead><tr><th align="left">语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">E#id</td><td align="left">代表 id 属性</td></tr><tr><td align="left">E.class</td><td align="left">代表 class 属性</td></tr><tr><td align="left">E[attr=foo]</td><td align="left">代表某一个特定属性</td></tr><tr><td align="left">E{foo}</td><td align="left">代表标签包含的内容是 foo</td></tr><tr><td align="left">E&gt;N</td><td align="left">代表 N 是 E 的子元素</td></tr><tr><td align="left">E+N</td><td align="left">代表 N 是 E 的同级元素</td></tr><tr><td align="left">E^N</td><td align="left">代表 N 是 E 的上级元素</td></tr></tbody></table><blockquote><p><strong>基础用法</strong></p></blockquote><p>元素(<code>Elements</code>) 您可以使用元素的名称，如 <code>div</code> 或 <code>p</code> 来生成 <code>HTML</code> 标签。<code>Emmet</code> 没有一组可用的标签名称，可以写任何单词并将其转换为标签。也就是只要知道元素的缩写,<code>Emmet</code> 会自动转换成对应标签. 形如:</p><table><thead><tr><th align="left">快捷键</th><th align="left">标签</th></tr></thead><tbody><tr><td align="left"><code>div </code></td><td align="left"><code>&lt;div&gt; &lt;/div&gt; </code></td></tr><tr><td align="left"><code>foo </code></td><td align="left"><code>&lt;foo&gt; &lt;/foo&gt; </code></td></tr><tr><td align="left"><code> html:5</code></td><td align="left">将生成<code>html5</code>标准的包含<code>body</code>为空基本<code>dom</code></td></tr><tr><td align="left"><code>html:xt</code></td><td align="left">生成<code>XHTML</code>过渡文档类型,<code>DOCTYPE</code>为<code>XHTML</code></td></tr><tr><td align="left"><code>html:4s</code></td><td align="left">生成<code>HTML4</code>严格文档类型,<code>DOCTYPE</code>为<code>HTML 4.01</code></td></tr><tr><td align="left"><code>a:mail </code></td><td align="left"><code>&lt;a href=&quot;mailto:&quot;&gt;&lt;/a&gt;</code></td></tr><tr><td align="left"><code>a:link </code></td><td align="left"><code>&lt;a href=&quot;http://&quot;&gt;&lt;/a&gt; </code></td></tr><tr><td align="left"><code>base </code></td><td align="left"><code>&lt;base href=&quot;&quot;&gt; </code></td></tr><tr><td align="left"><code>br </code></td><td align="left"><code>&lt;br&gt; </code></td></tr><tr><td align="left"><code>link </code></td><td align="left"><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;</code></td></tr><tr><td align="left"><code> script:src</code></td><td align="left"><code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt; </code></td></tr><tr><td align="left"><code> form:get</code></td><td align="left"><code>&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;&lt;/form&gt;</code></td></tr><tr><td align="left"><code> label</code></td><td align="left"><code>&lt;label for=&quot;&quot;&gt;&lt;/label&gt;</code></td></tr><tr><td align="left"><code> input</code></td><td align="left"><code>&lt;input type=&quot;text&quot;&gt;</code></td></tr><tr><td align="left"><code> inp</code></td><td align="left"><code>&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt;</code></td></tr><tr><td align="left"><code> input:hidden</code></td><td align="left"><code>&lt;input type=&quot;hidden&quot; name=&quot;&quot;&gt;</code>(<code>input:h</code>亦可)</td></tr><tr><td align="left"><code> input:email</code></td><td align="left"><code>&lt;input type=&quot;email&quot; name=&quot;&quot; id=&quot;&quot;&gt;</code></td></tr><tr><td align="left"><code> input:password</code></td><td align="left"><code>&lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot;&gt;</code></td></tr><tr><td align="left"><code> input:checkbox</code></td><td align="left"><code>&lt;input type=&quot; checkbox&quot; name=&quot;&quot; id=&quot;&quot;&gt;</code></td></tr><tr><td align="left"><code> input:radio</code></td><td align="left"><code>&lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot;&gt;</code></td></tr><tr><td align="left"><code> select</code></td><td align="left"><code>&lt;select name=&quot;&quot; id=&quot;&quot;&gt;&lt;/select&gt;</code></td></tr><tr><td align="left"><code> option</code></td><td align="left"><code>&lt;option value=&quot;&quot;&gt;&lt;/option&gt;</code></td></tr><tr><td align="left"><code> bq</code></td><td align="left"><code>&lt;blockquote&gt;&lt;/blockquote&gt;</code></td></tr><tr><td align="left"><code> btn</code></td><td align="left"><code>&lt;button&gt;&lt;/button&gt;</code></td></tr><tr><td align="left"><code> btn:s</code></td><td align="left"><code>&lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;</code></td></tr><tr><td align="left"><code> btn:r</code></td><td align="left"><code>&lt;button type=&quot;reset&quot;&gt;&lt;/button&gt;</code></td></tr></tbody></table><p>文本操作符(<code>&#123;Text&#125;</code>) 如果想在生成元素的同时添加文本内容可以使用<code>&#123;&#125;</code>(标签内的内容):</p><p>即：标签要不要带内容的快速生成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- a&#123;Click me&#125; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=<span class="string">&quot;&quot;</span>&gt;Click me&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- div&#123;这是一段文本&#125; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;这是一段文本&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- a&#123;点我点我&#125; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=<span class="string">&quot;&quot;</span>&gt;点我点我&lt;/a&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注</strong></p><p>当<code>&#123;&#125;</code>作为单独的一个操作符使用时，<code>a&#123;click&#125;</code>和<code>a&gt;&#123;click&#125;</code>将生成相同的标签，但当使用了多个，或用了其它操作符时将会生成不同的标签</p></blockquote><p>属性操作符(<code>Attribute operators</code>) 属性运算符用于修改输出元素的属性.</p><blockquote><p>选择器：<code>Id</code>和<code>Class</code> (<code>#id and .class</code>)<br>给标签指定<code>id</code>和<code>class</code>选择器，只需在标签的后面直接添加，但必需以<code>.</code>或<code>#</code>开头。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- div.test --&gt;&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;test&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- div#pageId  --&gt;&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;pageId&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- div#header+div.page+div#footer.class1.class2.class3 --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;header&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;page&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;footer&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;class1 class2 class3&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>隐式标签则会自动联想生成对应元素,根据配置规则不同生成的结果也是不同的，<code>.</code>是表示生成的是：<code>&lt;divclass=&quot;className&quot;&gt;第N个盒子&lt;/div&gt;。</code></p><p>绑定多个类名用<code>.</code>符号连续起来即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- div.className&#123;第$个盒子&#125;*<span class="number">5</span> --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;className&quot;</span>&gt;第<span class="number">1</span>个盒子&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;className&quot;</span>&gt;第<span class="number">2</span>个盒子&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;className&quot;</span>&gt;第<span class="number">3</span>个盒子&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;className&quot;</span>&gt;第<span class="number">4</span>个盒子&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;className&quot;</span>&gt;第<span class="number">5</span>个盒子&lt;/div&gt;</span><br><span class="line">&lt;!-- div.test1.test2.test3 --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;test1 test2 test3&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>自定义属性：<code>[]</code>（英文下的中括号）</p><p>使用<code>[]</code>操作符给标签添加自定义属性：自定义属性使用 <code>[attr1=&#39;&#39; attr2=&#39;&#39;]</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--div[<span class="class"><span class="keyword">class</span></span>=className]&#123;第$个盒子&#125;*<span class="number">5</span>--&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;className&quot;</span>&gt;第<span class="number">1</span>个盒子&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;className&quot;</span>&gt;第<span class="number">2</span>个盒子&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;className&quot;</span>&gt;第<span class="number">3</span>个盒子&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;className&quot;</span>&gt;第<span class="number">4</span>个盒子&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;className&quot;</span>&gt;第<span class="number">5</span>个盒子&lt;/div&gt;</span><br><span class="line">&lt;!-- a[href=<span class="string">&#x27;#&#x27;</span> data-title=<span class="string">&#x27;customer&#x27;</span> target=<span class="string">&#x27;_blank&#x27;</span>] --&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;#&quot;</span> data-title=<span class="string">&quot;customer&quot;</span> target=<span class="string">&quot;_blank&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- td[title=<span class="string">&quot;Hello world!&quot;</span> colspan=<span class="number">3</span>] --&gt;</span><br><span class="line">&lt;td title=<span class="string">&quot;Hello world!&quot;</span> colspan=<span class="string">&quot;3&quot;</span>&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure><p>可以把你喜欢的一些属性放在<code>[]</code>内，如果不指定属性值，代码将生成不带属性值的<code>HTML</code>默认标签：属性值必需使用单引号或双引号，不然就会出现你可能想到的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 错误示范，实际是想要一个 colspan=<span class="string">&quot;title&quot;</span> 的属性 --&gt;</span><br><span class="line">&lt;!-- td[colspan title] --&gt;</span><br><span class="line">&lt;td colspan=<span class="string">&quot;&quot;</span> title=<span class="string">&quot;&quot;</span>&gt;&lt;/td&gt;</span><br></pre></td></tr></table></figure></blockquote><p>嵌套操作符<code>(Nesting operators)</code> 嵌套操作符用于将缩写元素放置在生成的树中,是否应放置在上下文元素的内部或附近.</p><blockquote><p>父子关系:<code>&gt;</code></p><p>通过<code>&gt;</code>标识元素可以生成嵌套子级元素,可以配合元素属性进行连写,使用<code>&gt;</code>操作符在内部相互嵌套的标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ul&gt;li&gt;a --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">-------------------------</span><br><span class="line">&lt;!--  div#pageId&gt;ul&gt;li --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;pageId&quot;</span>&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>兄弟关系 \ 同级:<code>+</code></p><p>使用<code>+</code>操作符将标签处于同一个层级：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- div#pageId+div.child  --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;pageId&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;child&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;!-- div+p+footer --&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;footer&gt;&lt;/footer&gt;</span><br></pre></td></tr></table></figure><p>像<code>ul</code> <code>dl</code>这样的列表标签，使用+操作符将生成&gt;一个标准的列表结构(vscode 无效):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ul+ --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;!-- dl+ --&gt;</span><br><span class="line">&lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">  &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br><span class="line">&lt;!-- 本项在vscode中无效 --&gt;</span><br></pre></td></tr></table></figure><p>父级:<code>^</code></p><p>用于生成父级元素的同级元素,从这个字符所在位置开始,查找左侧最近的元素的父级元素并生成其兄弟级元素.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用 <span class="string">`^`</span> 操作符使标签与前一标签的父级处于相同的级别： --&gt;</span><br><span class="line">&lt;!-- div&gt;p.parent&gt;span.child^ul.brother&gt;li --&gt;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">   &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;parent&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">   &lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;brother&quot;</span>&gt;</span><br><span class="line">       &lt;li&gt;&lt;/li&gt;</span><br><span class="line">   &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- div+div&gt;p&gt;span+em^bq --&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">  &lt;blockquote&gt;&lt;/blockquote&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用两^操作符就与前一标签的爷爷级是相同级&gt;别，依此类推： --&gt;</span><br><span class="line">&lt;!-- div+div&gt;p&gt;span+em^^bq --&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;blockquote&gt;&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure></blockquote><p>分组操作符(<code>Grouping</code>)</p><p>分组使用<code>()</code>来实现缩写的分离.比如这个例子,如果不加括号那么<code>a</code>将作为<code>span</code>的子级元素生成.加上括号<code>a</code>将于<code>()</code>内的元素同级.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 可以使用多个<span class="string">`()`</span>，并使用乘法<span class="string">`*`</span>操作符 --&gt;</span><br><span class="line">&lt;!-- div&gt;(ul&gt;li+span)&gt;a --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;/li&gt;</span><br><span class="line">        &lt;span&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- div&gt;(header&gt;ul&gt;li*<span class="number">2</span>&gt;a)+footer&gt;p --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;footer&gt;</span><br><span class="line">        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- (div&gt;dl&gt;(dt+dd)*<span class="number">3</span>)+footer&gt;p --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">        &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">        &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">        &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">        &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">        &lt;dt&gt;&lt;/dt&gt;</span><br><span class="line">        &lt;dd&gt;&lt;/dd&gt;</span><br><span class="line">    &lt;/dl&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;footer&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure><p>乘法(<code>Multiplication</code>)</p><p><code>*</code>:要生成多少个一样的标签，后面加数字</p><p>使用<code>*N</code>即可自动生成重复项<code>.N</code>是一个正整数.在使用时请注意<code>N</code>所在位置,位置不同生成的结果不同.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- div&gt;ul&gt;li*<span class="number">5</span> --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- ul&gt;li.item$*<span class="number">5</span> --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item1&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item2&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item3&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item4&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item5&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;!-- ul&gt;(li&gt;a)*<span class="number">3</span> --&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;!-- ul&gt;(li&gt;a[click=<span class="string">&quot;#&quot;</span>])*<span class="number">3</span> --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span><span class="attr">click</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span><span class="attr">click</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span><span class="attr">click</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;!-- h[title=item]&#123;Header $&#125;*<span class="number">3</span> --&gt;</span><br><span class="line">&lt;h1 title=<span class="string">&quot;item1&quot;</span>&gt;Header <span class="number">1</span>&lt;/h1&gt;</span><br><span class="line">&lt;h2 title=<span class="string">&quot;item2&quot;</span>&gt;Header <span class="number">2</span>&lt;/h2&gt;</span><br><span class="line">&lt;h3 title=<span class="string">&quot;item3&quot;</span>&gt;Header <span class="number">3</span>&lt;/h3&gt;</span><br></pre></td></tr></table></figure><p><code>$</code>：标签的名称序号</p><p>即：生成的标签要不要自动生成带序号的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ul&gt;li.item$&#123;item number:$&#125;*<span class="number">3</span> --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item1&quot;</span>&gt;item number:<span class="number">1</span>&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item2&quot;</span>&gt;item number:<span class="number">2</span>&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item3&quot;</span>&gt;item number:<span class="number">3</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>如果生成两位数则使用两个连续的<code>$$</code>,更多位数以此类推…</p><p>使用多个<code>$</code>操作符用<code>0</code>来分填充数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ul&gt;li.item$$$*<span class="number">5</span> --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item001&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item002&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item003&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item004&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item005&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>使用<code>@</code>修饰符，可以更改编号方向（升序或降序）和基数（例如起始值）<code>.</code>注意这个操作符在<code>$</code>之后添加</p><p><code>@-</code>表示降序,<code>@+</code>表示升序,默认使用升序.</p><p><code>@N</code> 可以改变起始值<code>.</code>需要注意的是如果配合升降序使用的话 <code>N</code>是放到<code>+</code> \ <code>-</code>符后.</p><p>起始数字，在前添加<code>@</code>起始数字：<code>*</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ul&gt;li.item$@<span class="number">3</span>*<span class="number">5</span> --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item3&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item4&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item5&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item6&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item7&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>从起始数字为<code>3</code>的列表倒序，只需把上面的<code>Emmet</code>代码<code>item</code>后面的数字写成<code>@-3*5</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ul&gt;li.item$@-*<span class="number">5</span> --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item5&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item4&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item3&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item2&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item1&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;!-- ul&gt;li.item$@-*<span class="number">3</span> --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item3&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item2&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item1&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">---------------------------</span><br><span class="line">&lt;!-- ul&gt;li.item$@-<span class="number">10</span>*<span class="number">3</span> --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item12&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item11&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item10&quot;</span>&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><code>* </code>倒序在<code>vscode</code>中无效</p><p>另外如果你的编辑器中已经有了一些<code>html</code>智能提示代码段,比如我的<code>VsCode</code>还装了<code>HTML Snippets</code>插件,这个与<code>Emmet</code>语法有部分冲突,使用<code>Tab</code>键时会优先使用插件的代码提示,建议禁用.</p><p>组合起来看看效果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- table.table-row[role=<span class="string">&#x27;table&#x27;</span>]&gt;(thead&gt;tr&gt;td&#123;item $@<span class="number">120</span>&#125;*<span class="number">5</span>)+(tbody&gt;tr&gt;(td.item$$@-)lorem10*<span class="number">5</span>) --&gt;</span><br><span class="line">&lt;table <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;table-row&quot;</span> role=<span class="string">&quot;table&quot;</span>&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;item <span class="number">120</span>&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;item <span class="number">121</span>&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;item <span class="number">122</span>&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;item <span class="number">123</span>&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;item <span class="number">124</span>&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item05&quot;</span>&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Odit, assumenda.&lt;/td&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item04&quot;</span>&gt;Magnam possimus molestias ipsum animi rem placeat, ut obcaecati laudantium.&lt;/td&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item03&quot;</span>&gt;Consequuntur, labore ad optio cupiditate iusto dolores fugit quidem officiis.&lt;/td&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item02&quot;</span>&gt;Veniam, explicabo consequuntur blanditiis at dicta fuga ratione eos beatae.&lt;/td&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item01&quot;</span>&gt;Fuga voluptatum illo quis ducimus ad eveniet non. Saepe, eveniet.&lt;/td&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>这段目的在于生成一个类名为<code>table-row</code>,且自定义了属性<code>role</code>的<code>table</code>标签,内部包含了<code>thead</code>与<code>tbody</code>,分别生成 5 个<code>td</code>.</p><p><code>thead</code>中<code>td</code>的内容是<code>item</code>加上自增序号,自增序号基数从<code>120</code>开始.</p><p><code>tbody</code>中<code>td</code>拥有一个名为<code>item</code>加降序自增符号类名,且每个<code>td</code>内容随机填充<code>10</code>个单词.</p><p>配合嵌套元素和计数的例子.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- div.nav&gt;(nav#navbar&gt;(ul&gt;li&gt;(a[href=<span class="string">&quot;/xxx/product/$&quot;</span> data-index=$]&gt;lorem4)*<span class="number">5</span>))+div.btn[type=<span class="string">&#x27;button&#x27;</span>]&gt;span&#123;--&#125;^^div#main --&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;nav&quot;</span>&gt;</span><br><span class="line">    &lt;nav id=<span class="string">&quot;navbar&quot;</span>&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;/xxx/product/1&quot;</span> data-index=<span class="string">&quot;1&quot;</span>&gt;Lorem ipsum dolor sit.&lt;/a&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;/xxx/product/2&quot;</span> data-index=<span class="string">&quot;2&quot;</span>&gt;Dolor vel, quia quas.&lt;/a&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;/xxx/product/3&quot;</span> data-index=<span class="string">&quot;3&quot;</span>&gt;Qui hic, corrupti eum!&lt;/a&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;/xxx/product/4&quot;</span> data-index=<span class="string">&quot;4&quot;</span>&gt;Necessitatibus perspiciatis, corrupti. Praesentium!&lt;/a&gt;</span><br><span class="line">                &lt;a href=<span class="string">&quot;/xxx/product/5&quot;</span> data-index=<span class="string">&quot;5&quot;</span>&gt;Nostrum quos, voluptate. Velit!&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;btn&quot;</span> type=<span class="string">&quot;button&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>--<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;main&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo系列-撰写文章</title>
      <link href="/2021/05/25/hexo%E7%B3%BB%E5%88%97%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/"/>
      <url>/2021/05/25/hexo%E7%B3%BB%E5%88%97%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在利用 Hexo 框架搭建一个属于我们自己的博客网站后，下面我们就来谈谈怎样在网站上书写我们的第一篇博客吧</p><h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><p>在站点文件夹中打开 git bash，输入如下命令创建文章，其中 <code>title</code> 为文章的标题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="string">&quot;title&quot;</span></span><br></pre></td></tr></table></figure><p>当输入命令后，就会在 <code>source/\_post</code> 文件夹下创建一个文件，命名为：<code>title.md</code></p><p>这个文件就是将要发布到网站上的原始文件，用于记录文章内容</p><p>下面，我们将要在这个文件中写下我们的第一篇博客</p><h2 id="编写文章（基于-Markdown）"><a href="#编写文章（基于-Markdown）" class="headerlink" title="编写文章（基于 Markdown）"></a>编写文章（基于 Markdown）</h2><h3 id="Markdown-简介"><a href="#Markdown-简介" class="headerlink" title="Markdown 简介"></a>Markdown 简介</h3><p>但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？</p><blockquote><p>Markdown 是一种可以使用普通文本编辑器编写的 <strong>标记语言</strong>，通过简单的 <strong>标记语法</strong>，它可以使普通文本内容具有一定的格式</p></blockquote><p>基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言</p><h3 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h3><p>在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora</p><p>按照官方的说法就是 <strong>简单而强大</strong>，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览</p><p>这里附上 Typora 的下载地址：<a href="https://www.typora.io/%EF%BC%8C%E6%9C%89%E5%85%B4%E8%B6%A3%E7%9A%84%E6%9C%8B%E5%8F%8B%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BD%E6%9D%A5%E8%AF%95%E8%AF%95">https://www.typora.io/，有兴趣的朋友可以下载来试试</a></p><p>好，下面开始进入正题，介绍一些常用的 Markdown 语法</p><h4 id="（1）标题"><a href="#（1）标题" class="headerlink" title="（1）标题"></a>（1）标题</h4><p><strong>Markdown 语法</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题</span><br><span class="line"></span><br><span class="line">##### 五级标题</span><br><span class="line"></span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键</strong>：</p><p>Ctrl+1：一级标题</p><p>Ctrl+2：二级标题</p><p>Ctrl+3：三级标题</p><p>Ctrl+4：四级标题</p><p>Ctrl+5：五级标题</p><p>Ctrl+6 ：六级标题</p><p>Ctrl+0：段落</p><h4 id="（2）粗体、斜体、删除线和下划线"><a href="#（2）粗体、斜体、删除线和下划线" class="headerlink" title="（2）粗体、斜体、删除线和下划线"></a>（2）粗体、斜体、删除线和下划线</h4><p><strong>Markdown 语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_斜体_</span><br><span class="line">**粗体**</span><br><span class="line">**_加粗斜体_**</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键</strong>：</p><p>Ctrl+I：斜体</p><p>Ctrl+B：粗体</p><p>Ctrl+U：下划线</p><p>Alt+Shift+5：删除线</p><h4 id="（3）引用块"><a href="#（3）引用块" class="headerlink" title="（3）引用块"></a>（3）引用块</h4><p><strong>Markdown 语法</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文字引用</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键</strong>： Ctrl+Shift+Q</p><h4 id="（4）代码块"><a href="#（4）代码块" class="headerlink" title="（4）代码块"></a>（4）代码块</h4><p><strong>Markdown 语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`行内代码`</span></span><br><span class="line"></span><br><span class="line">​<span class="string">` 多行代码 多行代码 ​`</span></span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键</strong>：</p><p>行内代码：Ctrl+Shift+`</p><p>多行代码：Ctrl+Shift+K</p><h4 id="（5）公式块"><a href="#（5）公式块" class="headerlink" title="（5）公式块"></a>（5）公式块</h4><p>Markdown 语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$;</span><br><span class="line">数学公式;</span><br><span class="line">$$;</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键</strong>： Ctrl+Shift+M</p><h4 id="（6）分割线"><a href="#（6）分割线" class="headerlink" title="（6）分割线"></a>（6）分割线</h4><p><strong>Markdown 语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：---</span><br><span class="line"></span><br><span class="line">方法二：+++</span><br><span class="line"></span><br><span class="line">方法三：\*\*\*</span><br></pre></td></tr></table></figure><h4 id="（7）列表"><a href="#（7）列表" class="headerlink" title="（7）列表"></a>（7）列表</h4><p><strong>Markdown 语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 有序列表项</span><br><span class="line"></span><br><span class="line">- 无序列表项</span><br><span class="line"></span><br><span class="line">* 无序列表项</span><br><span class="line"></span><br><span class="line">- 无序列表项</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键</strong>：</p><p>有序列表项：Ctrl+Shift+[</p><p>无序列表项：Ctrl+Shift+]</p><h4 id="（8）表格"><a href="#（8）表格" class="headerlink" title="（8）表格"></a>（8）表格</h4><p><strong>Markdown 语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 表头 <span class="number">1</span>  | 表头 <span class="number">2</span>  |</span><br><span class="line">| ------- | ------- |</span><br><span class="line">| 内容 <span class="number">11</span> | 内容 <span class="number">12</span> |</span><br><span class="line">| 内容 <span class="number">21</span> | 内容 <span class="number">22</span> |</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键</strong>： Ctrl+T</p><h3 id="（9）超链接"><a href="#（9）超链接" class="headerlink" title="（9）超链接"></a>（9）超链接</h3><p><strong>Markdown 语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：[链接文字](链接地址 <span class="string">&quot;链接描述&quot;</span>)</span><br><span class="line">例如：[示例链接](https:<span class="comment">//www.example.com/ &quot;示例链接&quot;)</span></span><br><span class="line"></span><br><span class="line">方法二：&lt;链接地址&gt;</span><br><span class="line">例如：&lt;https:<span class="comment">//www.example.com/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键</strong>： Ctrl+K</p><h4 id="（10）图片"><a href="#（10）图片" class="headerlink" title="（10）图片"></a>（10）图片</h4><p><strong>Markdown 语法</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片文字](图片地址 <span class="string">&quot;图片描述&quot;</span>)</span><br><span class="line">例如：![示例图片](https:<span class="comment">//www.example.com/example.PNG &quot;示例图片&quot;)</span></span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键</strong>： Ctrl+Shift+I</p><p>说明：在 Hexo 中 插入图片时，请按照以下的步骤进行设置</p><p>将 站点配置文件 中的 <code>post_asset_folder</code> 选项的值设置为 true</p><p>在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件</p><p>这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/\_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![示例图片](title/example.PNG &quot;示例图片&quot;) </code>添加图片</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUEX</title>
      <link href="/2021/05/23/VUEX/"/>
      <url>/2021/05/23/VUEX/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>vuex</p></blockquote><p>状态管理器，整个项目里面被依赖的公共状态存放的地方 状态===数据 全局状态管理面。 cookie 里 都是死的。 vuex 的状态是数据双向绑定，意味着，挡状态被改变，页面上会跟着改变</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i vuex -S or yarn add vuex-S</span><br><span class="line"></span><br><span class="line">npm i axios -S</span><br></pre></td></tr></table></figure><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>管理状态的，组件里的 <code>data</code> 是很相以的，也是数据双向监听的。 它的辅助函数是 <code>mapState</code></p><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>它是对 <code>state</code> 进行计算的，相当于组件里的计算属性。它返回一个新的值。且不可以改变 <code>state</code> 状态</p><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>它是用来修改 <code>state</code> 状态的，并且只能是同步函数。 语法：语法 <code>mutations(state,newstr)</code>调用时用 <code>commit(&#39;mutations&#39;,data)</code></p><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>执行导步函数，调用 <code>mutaitions</code> 方法修改 <code>state</code>。 语法：<code>actio(&#123; commit), newStr&#125;</code>调用使用 <code>dispatch(&quot;action&quot;,data)</code></p><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>将不同模块使用的状态分成孤立的 <code>store</code>，然后挂载到根 <code>store</code> 上。让装套管理更加结构清理，孤立使用，又可互访问。</p><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>对 <code>vuex</code> 功能的，可安装多个插件，辅助 <code>vuex</code> 创建 <code>store</code> 的。</p><h3 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h3><p>开启 <code>store</code>的产格模式，默认是 <code>false</code> 关闭的，一旦开启，就执行产格模式，比如 <code>state</code> 状态只能在 <code>mutaitions</code> 里修改。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue高级用法</title>
      <link href="/2021/05/17/Vue%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/2021/05/17/Vue%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>mixin</strong></p><p>应⽤：抽离公共逻辑(逻辑相同，但是模板不⼀样，可⽤ mixin)</p><p>缺点：数据来源不明确</p><p>全局混⼊：会影响每⼀个之后创建的 Vue 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理⼀些逻辑</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>局部混⼊</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixins:[...]</span><br></pre></td></tr></table></figure><p>element-ui 中的 mixin 应⽤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">name: <span class="string">&#x27;ElDialog&#x27;</span>,</span><br><span class="line">mixins: [Popup, emitter, Migrating],</span><br><span class="line">props: &#123;</span><br><span class="line">title: &#123;</span><br><span class="line">type: <span class="built_in">String</span>,</span><br><span class="line"><span class="keyword">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并策略</p><p>数据对象，在内部会进⾏递归合并，并在发⽣冲突时以组件数据优先</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">      foo: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&quot;goodbye&quot;</span>,</span><br><span class="line">      bar: <span class="string">&quot;def&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$data);</span><br><span class="line">    <span class="comment">// =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同名钩⼦函数将合并为⼀个数组，因此都将被调⽤。另外，混⼊对象的钩⼦将在组件⾃身钩⼦之前调 ⽤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;混⼊对象的钩⼦被调⽤&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;组件钩⼦被调⽤&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// =&gt; &quot;混⼊对象的钩⼦被调⽤&quot;</span></span><br><span class="line"><span class="comment">// =&gt; &quot;组件钩⼦被调⽤&quot;</span></span><br></pre></td></tr></table></figure><p>值为对象的选项，例如 methods、components 和 directives，将被合并为同⼀个对象。两个对象键 名冲突时，取组件对象的键值对。</p><p><strong>插槽</strong></p><p>默认插槽</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog&gt;</span><br><span class="line"> &lt;div&gt;这是⼀段信息&lt;/div&gt;</span><br><span class="line">&lt;/el-dialog&gt;</span><br><span class="line"><span class="comment">// el-dialog</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line"> &lt;div&gt;弹窗&lt;/div&gt;</span><br><span class="line"> &lt;slot&gt;这是默认的内容&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>具名插槽</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-dialog&gt;</span><br><span class="line"> &lt;div&gt;这是⼀段信息&lt;/div&gt;</span><br><span class="line"> &lt;template v-slot:footer&gt;</span><br><span class="line"> &lt;div&gt;footer&lt;/div&gt;</span><br><span class="line"> &lt;/template&gt;</span><br><span class="line">&lt;/el-dialog&gt;</span><br><span class="line"><span class="comment">// el-dialog</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line"> &lt;div&gt;弹窗&lt;/div&gt;</span><br><span class="line"> &lt;slot&gt;默认内容&lt;/slot&gt;</span><br><span class="line"> &lt;slot name=<span class="string">&quot;footer&quot;</span>&gt;默认footer&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>插件</strong></p><p>插件通常⽤来为 Vue 添加全局功能，⽐如 vue-router vuex</p><p>注册插件<br>Vue.use(VueRouter); Vue.use(Vuex)<br>Vue.use 会⾃动阻⽌多次注册相同插件，届时即使多次调⽤也只会注册⼀次该插件。</p><p>编写插件<br>插件暴露 install ⽅法<br>Vue.use(MyPlugin, options)会执⾏插件的 install ⽅法，并传⼊ Vue 和 options</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 1. 添加全局⽅法或 property</span></span><br><span class="line">Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 逻辑...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 添加全局资源</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line"><span class="comment">// 逻辑...</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3. 注⼊组件选项</span></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 逻辑...</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 4. 添加实例⽅法</span></span><br><span class="line">Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 逻辑...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器<br>定义：将原数据进⾏格式化显示，⽽不改变原数据<br>应⽤：货币符号、时间格式化（⼀般⽤在与业务关联不⼤的情况下，否则⽤ computed）<br>全局过滤器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">&#123;&#123; timer | format &#125;&#125;</span><br><span class="line"> &#123;&#123; timer | format(<span class="string">&#x27;YYYY:MM:DD hh:mm:ss&#x27;</span>) &#125;&#125;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/tempalte&gt;</span><br><span class="line"></span><br><span class="line">Vue.filter(<span class="string">&#x27;timeFormat&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val, formatter = <span class="string">&#x27;YYYY:MM:DD&#x27;</span></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 没有 this</span></span><br><span class="line"><span class="keyword">return</span> moment(val).format(formatter)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>局部过滤器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line"><span class="function"><span class="title">timeFormat</span>(<span class="params">val, formatter</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> moment(val).format(formatter)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Vue 响应式原理</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dep1 = <span class="keyword">new</span> Dep()</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.$data, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> dep1.depend() <span class="comment">// 收集依赖</span></span><br><span class="line"> <span class="keyword">return</span> value</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (newValue === value) <span class="keyword">return</span>;</span><br><span class="line"> value = newValue</span><br><span class="line"> dep1.notify() <span class="comment">// 通知依赖</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> dep2 = <span class="keyword">new</span> Dep()</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.$data, <span class="string">&#x27;info&#x27;</span>, &#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> dep3 = <span class="keyword">new</span> Dep()</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.$data.info, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>收集依赖</p><p>每个组件实例对应⼀个 watcher 实例<br>在组件渲染过程中，把“touch”过的数据记录为依赖(触发 getter -&gt; 将当前 watcher 实例收集到 属性对应的 dep 中)<br>触发更新<br>数据更新后 -&gt; 会触发属性对应的 setter -&gt; 通过 dep 去通知 watcher -&gt; 关联的组件重新渲染</p><p>注意：</p><ol><li>对象<br>vue ⽆法监测对象的添加 、<br>解决⽅案：this.$set(this.someObject, ‘b’ ,2)<br>注意：Vue 不允许动态添加根级别的响应式 property</li><li>数组<br>Object.defineProperty ⽆法监听数组索引值的变化,⽐如 this.a[0] = 44 ，解决⽅案：<br>this.$set(this.a, 0, 44)<br>this.a.splice(0, 1, 44)<br>数组⻓度的变化也⽆法监听 ，解决⽅案：<br>this.a.splice(newLength) // 省略第⼆个参数，表明删除从 newLength 及后⾯的数据<br>重写了数组的⽅法(push() pop() shift() unshift() splice() sort()reverse())<br>this.a[1].name = ‘lisi’ // 这是更改对象的属性值</li><li>其他<br>递归的循环 data 中的属性(可能会导致性能问题)对于⼀些数据获取后不更改，仅仅⽤来展示的数据(⽐如说省、市)可以使⽤ Object.freeze 来优化性能 this.city=Object.freeze(data.city)</li></ol><p><strong>动画</strong></p><p>单元素/组件动画(transition 组件)</p><p>css3 transition</p><p>v-enter<br>⽤来定义动画的初始状态<br>元素插⼊之前被添加，元素插⼊后被移除<br>v-enter-active<br>定义动画语句<br>元素插⼊之前被添加，动画结束后被移除<br>v-enter-to<br>⽤来定义动画的结束状态(⼀般不设置，因为元素有默认的显示状态，⽐如 opacity 默认为<br>元素插⼊后被添加，动画结束后被移除<br>v-leave<br>v-leave-active<br>v-leave-to</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端和后端是如何交互的</title>
      <link href="/2021/05/15/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A4%E4%BA%92%E7%9A%84/"/>
      <url>/2021/05/15/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A4%E4%BA%92%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前端请求数据-URL-由谁来写"><a href="#前端请求数据-URL-由谁来写" class="headerlink" title="前端请求数据 URL 由谁来写"></a>前端请求数据 URL 由谁来写</h2><blockquote><p>在开发中，URL 主要是由后台来写好给前端。<br>若后台在查询数据，需要借助查询条件才能查询到前端需要的数据时，这时后台会要求前端提供相关的查询参数（即 URL 请求的参数）。</p></blockquote><h2 id="接口文档主要由谁来写"><a href="#接口文档主要由谁来写" class="headerlink" title="接口文档主要由谁来写"></a>接口文档主要由谁来写</h2><blockquote><p>接口文档主要由后台设计和修改。<br>后台直接跟数据打交道，最清楚数据库里有什么数据，能返回什么数据。<br>前端只是数据的被动接受者，只是接口文档的使用者。<br>使用过程中，发现返回的数据部队，则跟后台商量，由后台修改。<br>切记：前端不能随意更改接口文档，除非取得后台同意。</p></blockquote><h2 id="前端与后台交互的数据格式"><a href="#前端与后台交互的数据格式" class="headerlink" title="前端与后台交互的数据格式"></a>前端与后台交互的数据格式</h2><blockquote><p>主要是 JSON，XML 现在用的不多</p></blockquote><h2 id="前端与后台的交互原理"><a href="#前端与后台的交互原理" class="headerlink" title="前端与后台的交互原理"></a>前端与后台的交互原理</h2><blockquote><p>关注点：接口地址、前端请求的参数、后端返回的参数。<br>调一下接口，看一下返回的数据。</p></blockquote><h2 id="前端请求参数的形式"><a href="#前端请求参数的形式" class="headerlink" title="前端请求参数的形式"></a>前端请求参数的形式</h2><blockquote><p>GET 和 POST 两种方式<br>GET 从指定的服务器中获取数据，POST 提交数据给指定的服务器处理</p></blockquote><h2 id="前端应该告知后台那些有效信息，后台才能返回前端想要的数据"><a href="#前端应该告知后台那些有效信息，后台才能返回前端想要的数据" class="headerlink" title="前端应该告知后台那些有效信息，后台才能返回前端想要的数据"></a>前端应该告知后台那些有效信息，后台才能返回前端想要的数据</h2><blockquote><p>先将要展示的页面内容进行模块划分，将模块的内容提取出来，以及方便前端的一些标志值等，将所有想要的内容和逻辑告知后端<br>后端从数据库里面去查询相应的数据表以获得相应的内容或者图片地址信息<br>URL 中的参数主要是根据后台需要，若后台需要一个参数作为查询的辅助条件，前端在 URL 数据请求时就传递参数</p></blockquote><h2 id="前端如何把页面信息有效传达给后台，以及后台如何获取到这些数据"><a href="#前端如何把页面信息有效传达给后台，以及后台如何获取到这些数据" class="headerlink" title="前端如何把页面信息有效传达给后台，以及后台如何获取到这些数据"></a>前端如何把页面信息有效传达给后台，以及后台如何获取到这些数据</h2><blockquote><p>所有前端请求的 URL 后面的参数都是辅助后台数据查询的<br>若不需要参数，那后台就会直接给个 URL 给前端</p></blockquote><h2 id="前端应该如何回拒一些本不属于自己做的一些功能需求或任务"><a href="#前端应该如何回拒一些本不属于自己做的一些功能需求或任务" class="headerlink" title="前端应该如何回拒一些本不属于自己做的一些功能需求或任务"></a>前端应该如何回拒一些本不属于自己做的一些功能需求或任务</h2><blockquote><p>前端负责把数据展示在页面上<br>清晰的认识自己需要做的需求和任务</p></blockquote><h2 id="当前端在调用数据接口时，发现有些数据不是我们想要的，那么前端应该怎么办"><a href="#当前端在调用数据接口时，发现有些数据不是我们想要的，那么前端应该怎么办" class="headerlink" title="当前端在调用数据接口时，发现有些数据不是我们想要的，那么前端应该怎么办"></a>当前端在调用数据接口时，发现有些数据不是我们想要的，那么前端应该怎么办</h2><blockquote><p>把请求的 URL 和返回的数据以及在页面的展示的情况给后台看【后台查询数据、取数据、封装数据方面等蛮难处理的】</p></blockquote><h2 id="为什么需要在请求的时候传入参数"><a href="#为什么需要在请求的时候传入参数" class="headerlink" title="为什么需要在请求的时候传入参数"></a>为什么需要在请求的时候传入参数</h2><blockquote><p>后台在查询数据库的时候需要条件查询</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前后端对接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端对接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端单词汇总</title>
      <link href="/2021/05/09/%E5%89%8D%E7%AB%AF%E5%8D%95%E8%AF%8D/"/>
      <url>/2021/05/09/%E5%89%8D%E7%AB%AF%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>style 修饰<br>width 宽度<br>height 高度<br>title 想说明的<br>text-align 水平对齐方式<br>center 居中 left 居左 right 居右<br>line-height 垂直对齐方式/行高 当行高等于高度时候垂直居中<br>background 背景<br>image 引入背景图片(url)<br>background-position： 背景定位(x 轴，y 轴；)<br>background-repeat 背景平铺<br>:no-repeat;不平铺 repeat-x;水平平铺 repeat-y;垂直平铺<br>background：url() repeat left center #00;<br>顺序：背景图片 重复 定位 颜色<br>top/right/bottom/left/center 方向英文：上、右、下、左，中<br>color 颜色</p><p>font 文字<br>font-family 字体<br>font-size 字号<br>font-weight：normal 正常 :bold 加粗<br>font-style: normal;取消倾斜 :italic;斜体<br>font:italic bold 24px/24px ‘楷体’;<br>顺序：是否斜体 是否粗体 字体大小/行高 字体<br>文本修饰属性：<br>text-decoration：<br>overline 顶划线<br>underline 下划线<br>line-through 中划线/删除线<br>none 无/取消下划线<br>display 转化显示模式 元素转化<br>block 块<br>inline 行内<br>inline-block 行内块</p><p>省略号<br>white-space:nowrap 强制不换行<br>overflow:hidden 溢出隐藏<br>text-overflow：ellipsis 省略号<br>font-family：‘微软雅黑’ 让省略号在下面<br>必须给宽度<br>伪类<br>a:link 设置未访问时候的颜色 点击后变成 a 的正常颜色<br>a:visited 设置访问过后颜色<br>a:hover 当鼠标放上去会变颜色<br>a:active 鼠标点击变颜色<br>顺序 lvha 驴哈</p><p>auto 自动居中<br>margin 外边距<br>margin-top 上外边距<br>margin-right 右外边距<br>margin-bottom 下外边距<br>margin-left 左外边距<br>padding 内边距<br>padding-top 上内边距<br>padding-right 右内边距<br>padding-bottom 下外边距<br>padding-left 左外边距<br>float 浮动 ：left|right|none 左|右|不浮动<br>cursor:pointer 小手的代码。。<br>clear：left|right|both 清除浮动<br>overflow：hidden 溢出隐藏</p><p>index 首页<br>base 里面写清除默认样式的<br>text-indent：em 首行缩进 （LOGO 名字）<br>以后 logo 必须用 H1 引背景图片 里面写上字<br>position：relative|absolute|fixed 定位<br>relative 相对定位<br>absolute 绝对定位<br>fixed 固定定位<br>Left/top/right/bottom 定位的偏移量<br>z-index 改变标签 z 轴堆叠顺序<br>opacity 透明代码 1 不透明（0.9 0.8.。。。。） 0 透明<br>filter：alpha（opacity：0-100）</p><p>input{outline:none} 取消焦点</p><form action="链接" method="">post 相对安全 get 不安全input 表单 单标签type="text" 账号/文本type="password" 密码type="submit" 提交type="button" 只是一个点击按钮type="radio" 单选框 label双标签 选项内容type="checkbox" 复选框 label双标签 选项内容value="提示 如 请输入密码"placeholder="也是提示"selectoption 选项栏textarea 下拉框resize：none 禁止任意拖放name="user" 账号name="password" 密码 table{ border-collapse:collapse;} 让border合并<p>tr 加</p><p>colspan=”3” 横向合并</p><p>rowspan=”3” 纵向合并</p><p>align 左右对齐方式 middle（左）left center right</p><p>valign 上下对齐方式 top center bottom</p><p>cellspacing=”0” 清除外面的边距</p><p>cellpadding=”0” 清楚里面的边距</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;table cellspacing=<span class="string">&quot;0&quot;</span> cellpadding=<span class="string">&quot;0&quot;</span>&gt;</span><br><span class="line">&lt;thead&gt;<span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span>&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;<span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>表身<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span>&lt;/tbody&gt;</span><br><span class="line">&lt;tfoot&gt;<span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>表低<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span>&lt;/tfoot&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">frameborder=<span class="string">&quot;0&quot;</span> 取消边框</span><br><span class="line">screlling=<span class="string">&quot;no&quot;</span> 取消滚动条</span><br><span class="line">iframe src</span><br><span class="line"></span><br><span class="line">&lt;frameset&gt;</span><br><span class="line">&lt;frame /&gt;</span><br><span class="line">&lt;/frameset&gt;</span><br></pre></td></tr></table></figure><p>letter-spacing：具体数值 字母间距</p><p>word-spacing：数值 单词间距</p><p>overflow：auto 溢出滚动</p><p>visibility：hidden 隐藏</p><p>charset 字符集</p><p>utf-8 国际编码</p><p>gb2312/gbk 中国编码</p><p>author 作者</p><p>copyright 版权</p><p>keywords 关键词</p><p>description 介绍</p><p>js<br>@media screen and (max-width:900px){}; 屏幕自适应</p><p>媒体 屏幕 最大</p><p>push :添加一个数组元素<br>document ：文档<br>pop ：删除最后一个数组元素<br>console ：控制台<br>shift ：删除第一个数组元素<br>string ：字符串<br>Concat 组合数组<br>undefined ：未定义<br>typeof ：关键字<br>join：数组转化为指定分隔符<br>slice：返回指定数组<br>length：数组长度<br>Array：数组<br>number：数字<br>boolean：布尔<br>alert：提示框<br>parseInt：转化为整型数值<br>continue：继续<br>is NaN：非数字<br>sort：升序<br>break：截断 跳出<br>reverse：倒序<br>object：对象类型<br>parseFloat：转化为浮点值<br>index：索引<br>floor：向下取整<br>variable：变量<br>ceil：向上取整<br>round:四舍五入<br>abs：返回绝对值<br>eval：解析字符串并运算<br>max：比较最大值<br>return：返回<br>min：比较最小值<br>addEventListener：事件名 函数<br>to.fixed：保留小数点<br>attachEvant：（on）事件名<br>random：随机数<br>eletment：元素<br>eventName：事件名<br>function：函数<br>removeEventListener：事件解除<br>detachEvent：删除已注册事件<br>open（）：弹出一个新窗口<br>function：函数（方法）<br>showModalDialog：弹出一个模式窗口<br>close()：关闭当前窗口<br>new Date()：日期对象<br>getFullYear（）：年份<br>getMonth（）：月份（0–11）<br>getDate（）：几号<br>getDay（）：星期几（周一至周六）<br>getHours（）：小时（0–23）<br>getMinites（）：分钟<br>getSeconds（）：秒数（0–59）<br>getMilliseconds（）：毫秒数<br>getTime（）：从 1970 至今的毫秒数<br>Date.now（）：从 1970 至今的毫秒值<br>tolocaleDatestring（）：输出本地化的日期<br>setTimeout：延迟时间<br>tolocaleTimestring（）：输出本地化得时间<br>clearTimeout：定时器对象<br>tolocalestring：输出本地化的日期和时间<br>setInterval：间隔时间<br>clearInterval：停止<br>window.status：浏览器状态栏信息<br>window.screen：屏幕信息<br>screen.width：屏幕宽度<br>screen.height：屏幕高度<br>screen.availwidth：去掉任务栏宽度<br>screen.avaiheight：去掉任务栏高度<br>history：浏览历史记录<br>location：地址栏对象<br>navigator：用于获取用户浏览器信息<br>appCodeName：浏览器代码名的字符串表示<br>appName：返回浏览器的名称<br>appVersion：返回浏览器的平台和版本信息<br>platform：返回运行浏览器的操作系统平台<br>userAgent：返回由客户机发送服务器的<br>user-agent：头部的值<br>Exception：异常 意外情况（try—catch）</p><p>获取元素对象方式:<br>getElementByld：<br>getElementsByName：<br>gatElementsByTagName：<br>getElementByClassName：<br>onlick 当点击的时候<br>onmouseover 鼠标移入<br>onmouseout 鼠标移出<br>onblur：失去焦点事件<br>onkeydown：键盘按下事件（前）<br>onkeypress：键盘按下事件（后）<br>onload：当页面加载完成之后触发<br>onchange;内容改变事件<br>onkeydown;键盘按下事件（前）<br>onkeyup;键盘松开事件<br>onkeypress;键盘按下事件（后）<br>onmouseout：鼠标移出事件<br>onmouseover：鼠标移入事件<br>onselect：内容被选中事件<br>ondblclick：鼠标双击事件<br>onfocus：获得焦点事件<br>onkeyup：键盘松开事件<br>复选框操作 checked=” “<br>checked 默认选中<br>false 不选中<br>true 选中<br>typeof 查看数据类型<br>object 对象<br>number 数字<br>string 字符串<br>function 函数<br>boolean 布尔值 true false<br>undefined 未定义<br>parseInt 整数<br>parseFloat 浮点数/小数<br>Number 数字</p><p>hide 隐藏<br>show 显示<br>skin 皮肤<br>code 代码<br>even 事件<br>array 数组<br>integer 整数<br>veruant 变量<br>common 公用<br>switch<br>case 情况<br>break 中断整个循环<br>continue 跳出本次循环<br>default 不履行/所有情况都不满足的时候走这个<br>null 没有/空对象<br>computed 计算后/生效的<br>eval（JS 可以读懂的代码：如‘1+1’-&gt;字符串） 这个代码会把（）里面的字符串换成计算机读懂的代码来计算 + - * % 都行 （计算用的）<br>return 返回<br>write 输入<br>find 查找</p><p>interval 间隔<br>setInterval（函数名，1000/） 间隔定时器<br>clearInterval 清除间隔定时器<br>Timeout 超时<br>setTimeout 延迟定时器<br>clearTimeout 清除延迟定时器<br>obj.disabled 让按钮/变成不可使用<br>true 不可用<br>false 可用<br>date 时间<br>get 获取<br>set 设置<br>Fullyear 满年<br>month 月 （从 0 月开始）<br>day 日 获取需要 date<br>week 星期 获取需要 day （从 0 到 6）<br>hours 小时<br>minutes 分钟<br>seconds 秒<br>single 一个/一倍<br>dubble 两个/两倍<br>triple 三个/三倍</p><p>arguments 函数传参-实参的集合<br>arguments.length 函数传参-实参的长度<br>arr.push（） 向数组最后添加一项<br>arr.unshift() 向数组前面添加一项<br>arr.pop（）删除数组最后一位.<br>arr.shift（） 删除数组第一位<br>arr.splice(开始的位置，删除的个数，添加的东西 1。。。)<br>arr.join(‘’) 变字符串 是中间的隔开东西 如- ，空格 等等。。。<br>arr.concat(arr1,arr2,arr..要拼接的数组…); 数组拼接/合并数组<br>arr.reverse() 反转/颠倒数组<br>arr.sort() 数组排序 按照字符串比大小的方法来排序<br>arr.sort(function(a1,a2){ return a1-a2 //从小到大 return a2-a1 //从大到小 }) a1 a2 随便起 代表的是数组中随机的某两项<br>str.charAt() 字符串里面的下标<br>str.indexOf(‘’) 下字符串对应的下标数（相同的就取第一个）<br>str.lastIndexOf（‘’）下字符串对应的下标数（相同的就取最后一个）<br>str.substring (开始位置，结束位置)/（开始位置-不写结束位置默认就从开始位置到最后） 截取子串<br>str.toUpperCase() 大写字母<br>str.toLowerCase() 小写字母<br>str.split(切割的方式 ‘-‘ ‘’ ‘空格’等) 切割变成数组<br>str.charCodeAt(‘a’) 输入字符查找对应的编码<br>String.fromCharCode(编码) 输入编码查找对应的字符<br>json.name=value; 添加<br>delete json.name 删除<br>token 括号<br>try{} catch(e) 异常<br>parseInt（math.random()（m-n）+n） 求 n-m 之间随机的整数， 前包括后不包括<br>Math.random() 求随机数<br>Math.abs() 求绝对值<br>Math.max(，，，) 求最大值<br>Math.min(，，，) 求最小值<br>Math.pow(n,m) 求 n 的 m 次方<br>Math.sqrt(a) 开方<br>Math.PI π<br>Math.ceil(12.3) 向上取整 13<br>Math.floor(12.3) 向下取整 12<br>Math.round(a) 四舍五入<br>!important Css 样式值后面加这个 权重最大<br>navigator.userAgent UA 例子判断浏览器的类型<br>navigator.language 语言<br>navigator.platform 操作系统</p><p>Sibling 兄弟<br>next 下一个<br>previous 上一个<br>获取元素/节点：<br>(父级) obj.children 找：儿子/子级 子节点<br>(子级) obj.parentNode 找：父亲/父级 父节点<br>(同级) obj.nextElementSibling || obj.nextSibling 下一个同级/节点 (同级) obj.previousElementSibling || obj.prenviousSibling 上一个同级/节点<br>(父级) obj.firstElementChild ||obj.firstChild 首节点<br>(父级) obj.lastElementChild || obj.lastChild 尾节点<br>创建元素：<br>document.createElement_x(‘标签名’) 创建元素<br>添加插入<br>(父级) obj.appendChild(谁) 往元素里面最后添加一个<br>带剪切效果<br>(父级) obj.insertBefore(把谁，加在谁的前面) 往元素里面添加一个<br>带剪切效果<br>删除元素：<br>(父级) obj.removeChild(子级) 删除子级<br>window.open() 打开<br>window.close() 关闭<br>a 标签：target=””<br>不填 默认新页面打开<br>_blank 新页面打开<br>_self 本页面打开<br>window.location 地址栏信息<br>window.location.href 链接信息<br>window.location.search 数据信息<br>window.location.hash 锚点信息 *了解就行 面试背住<br>window.location.procotol 协议信息<br>window.location.hostname 域名信息<br>window.location.port 端口号信息<br>window.location.pathname 路径信息</p><p>back 返回<br>forward 向前<br>history 历史<br>window.history.back 返回历史记录 退<br>window.history.forward 返回历史记录 前<br>alert（） 弹<br>confirm 询问提示框<br>prompt 问答提示框<br>console.log（） 在 F12 中显示;<br>document.write（*） 在页面中输入<br>scroll 滚动 有兼容问题<br>client 客户端/可视区<br>offsetHeight/Width 物体盒子模型的宽高<br>offsetTop/Bottom/方向 物体距上/下/左/右的距离<br>offsetparent 定位父级<br>window.onScroll 当滚动的时候 滚动事件<br>window.onresize 当缩放的时候 缩放事件<br>onfocus 当获取焦点的时候<br>onblur 当失去焦点的时候<br>obj.getAttribute(‘属性名’) 获取属性名对应的属性值<br>obj.setAttribute(‘属性名’,’属性值’) 设置属性<br>obj.removeAttribute(‘属性名’) 删除属性</p><p>event 事件<br>onmousemove 鼠标移动事件<br>onload 当图片加载完成时<br>onerror 当图片加载失败时<br>cancelBubble 取消冒泡<br>onkeydown 当按键按下的时候<br>onkeyup 当按键抬起的时候<br>oEvent.keycode 键盘编码<br>oncontextmenu 当按右键的时候<br>return false 阻止浏览器右键菜单<br>cache 缓存</p><p>onmousedown 鼠标按下时<br>onmouseup 鼠标抬起时<br>onmousemove 鼠标移动事件<br>obj.setCapture() 开始捕获<br>obj.releaseCapture() 取消捕获<br>obj.cloneNode() 克隆复制一个节点<br>document/obj.addEventListener（’不加 on 的事件名’,函数名,false） 添加事件绑定 兼容高级<br>document/obj.attachEvent（’加 on 的事件名’,函数名） 添加事件绑定 兼容 IE 系列<br>document/obj.removeEventListener（’不加 on 的事件名’,函数名,false） 解除事件绑定<br>document/obj.detachEvent（’加 on 的事件名’,函数名） 解除事件绑定</p><p>onmouseenter 鼠标移入<br>onmouseleave 鼠标移出<br>onmousewheel 鼠标滚轮事件<br>DOMMouseScroll 鼠标滚动事件<br>oEvent.wheelDelta 非火狐 测试鼠标滚轮向上向下弹得数字<br>oEvent.detail 火狐 测试鼠标滚轮向上向下弹得数字</p><p>return false 阻止浏览器默认事件 但是在事件绑定中失效<br>oEvent.preventDefoult 在事件绑定中用 阻止浏览器默认事件（如果单独用只兼容高级浏览器）<br>oninput 当输入的时候 iE9- 没有此方法<br>onpropertychange 当属性改变的时候 IE 系列<br>oEvent.srcElement 事件源 非火狐<br>oEvent.target 事件源 高级浏览器</p><p>duration 期间<br>start 开始<br>count 次数<br>complete 完成<br>var bFlag=false/ture 开关 自定义</p><p>easing 速度类型：<br>linear 匀速<br>ease-in 加速<br>ease-out 减速<br>window.onload 页面加载完毕后执行（代码、资源）<br>DOMReady 页面加载完毕后执行（代码）<br>DOMContentLoaded DOM 加载事件<br>obj.onreadystatechange 监控事件（模拟 DOM 加载事件）<br>readyState 加载状态<br>document/obj.readyState 加载状态<br>ondbclick 鼠标双击<br>queryselector 新的获取元素方法</p><p>window.location.reload 重新加载</p><p>cookie<br>expires 期限<br>session 一个会话（浏览器打开和关闭）<br>path 路径<br>define 定义<br>require 引用其他模块<br>exports 导出模块<br>module 批量导出模块，<br>data-main 主要数据/初始化接口</p><p>success 成功<br>error 失败</p><p>Request 请求<br>ActiveX 浏览器插件<br>XMLHttpRequest（） ajax 创建/ 不兼容 ie6-<br>ActiveXObject（’Microsoft.XMLHTTP’） 创建/(插件) ie 系列</p><p>oAjax.open()打开<br>oAjax.setRequestHeader(‘content-type’, ‘application/x-www-form-urlencoded’);<br>oAjax.send() 发送<br>onreadystatechange 接收/当通信状态变化</p><p>oAjax.abort() 使中止<br>oAjax.readyState 是否完成/加载状态<br>oAjax.status 是否成功<br>response 回答/响应<br>oAjax.responseText 返回结果</p><p>JSON.parse() 可以把字符串 json 变成 json 不过 json 要正规些 双引号<br>JSON.stringify() json 打印出来的方法</p><p>encode 编码<br>decode 解码<br>Component 组件/元件<br>encodeURIComponent(‘中文’) 中文转化成编码<br>decodeURIComponent(‘编码’) 编码转化成中文</p><p>str.replace 替换<br>new RegExp() 正则表达式<br>str.search() 跟 indexOf 一样 在正则用<br>str.match 匹配</p><p>正则.test（你要校验的 str） true 正确满足 false 不满足 用这个的时候一定配合行首和行尾<br>转译<br>\d 数字 [0-9]<br>\w 数字、英文、下划线 [0-9a-z]<br>\s 空白字符 所有的空白字符<br>. 代表任意字符<br>\D 非数字 [^0-9]<br>\W 非数字、英文、下划线 [^0-9a-z]<br>\S 非空白字符<br>\u4e00-\u9fa5 中文<br>量词<br>{n} n 个<br>{n,m} n-m 个<br>{n,} 最少 n 个，最多随便<br>{0，m} 最少随便 最多 m 个</p><p>{1，} 就是 若干个<br>{0，} 任意个 可以没有<br>？ {0,1} 最少没有 最多 1 个<br>\ 转译特殊字符</p><p>| 或的意思<br>i 忽略大小写<br>g 全局匹配<br>m 多行模式</p><p>^ 行首 如果在方括号里面是除了<br>$ 行尾<br>*jq<br>hide 隐藏<br>show 显示<br>toggle 点击<br>hover 移入<br>fadeIn 淡入<br>fadeOut 淡出<br>animate 运动函数（move）<br>slideDown 滑动从上往下出来<br>slideUp 滑动从下往上隐藏<br>eq(下标) 标签获取的下标<br>li&gt;a li 下面的第一级 a<br>伪类选择器:<br>li:last li 最后一个<br>li:first li 第一个<br>li:eq(2) 第三个 li<br>obj：even 偶数<br>obj：odd 奇数<br>obj：has(“p/标签名”) 里面包含‘p’这个标签的就会选取<br>obj：contains(“p/内容”) 内容有得‘p’ 就都会选取<br>event/自己起行参名字.pageX X 轴坐标<br>event/自己起行参名字.pageY Y 轴坐标<br>offset().top 物体绝对的位置 -&gt;getPos()函数<br>offset().left 物体绝对的位置<br>position().top 物体距定位父级距离 -&gt;offsetTop<br>position().left 物体距定位父级距离<br>document.scrollTop 和原生一样<br>document.scrollLeft 和原生一样<br>.width/.height 物体本身的宽高<br>innerHeight/Width 物体内部的宽高 包括 padding 不包括边框<br>outerHeight/Width 物体盒子模型宽高<br>父级.append(子级) 在父级内的后部追加<br>父级.prepend(子级) 在父级内的前面追加<br>子级.appendTo(父级) 在父级后部追加<br>子级.prependTo(父级) 在父级前部追加<br>obj1.after(obj2) 把 2 放在 1 的后面<br>obj1.before(obj2) 把 2 放在 1 的前面<br>bind() 事件绑定<br>unbind() 事件解绑<br>live() 事件委托<br>die() 解除事件委托<br>**以上四种不推荐 因为原理还是昂 所以推荐 on<br>obj.on（） 可以事件绑定/委托</p><p>each 循环<br>$.trim() 去除首尾空格</p><p>extend() 延伸<br>height() 就是宽度<br>innerHeight 包括 padding、不包括边框<br>outerHeight 盒子模型的<br>offset().left -&gt; getPos()<br>position().left -&gt; offsetLeft()<br>scrollTop() -&gt; scrollTop<br>eve.pageX/Y 坐标<br>maxlength 表单元素最大长度 属性<br>$.fn.函数名=function(){} 建立jq封装函数<br>$.fn.extend({函数名 1:function(){},函数名 2:function(){},…})</p><p>汉字：[0x4e00,0x9fa5]（或十进制[19968,40869]）<br>数字：[0x30,0x39]（或十进制[48, 57]）<br>小写字母：[0x61,0x7a]（或十进制[97, 122]）<br>大写字母：[0x41,0x5a]（或十进制[65, 90]）<br>parent() 父级<br>offsetParent() 定位父级<br>parents() 所有父级 括号里面可以筛选 比如放 class 名字或…<br>str/arr.slice（开始位置，结束位置） 切 从开始到结束 如果只有开始 就从开始到最后。 前包后不包</p><p>prototype 原型<br>form 表单中 submit 提交 reset 重置<br>xxx instanceOf xxx 检测一个对象属于某个类<br>xxx.constructor==xxx 看构造函数 双等是判断 直接父级属不属于 xxx 一个等号是赋值让直接父级等于 xxx<br>fn.call(this 的指向，参数一，参数二，….) 改变 this 的指向 fn 中的 this=<br>fn.apply(this 的指向，[参数一，参数二，….]) 改变 this 的指向 fn 中的 this=<br>init 开始</p><p>localStorage 本地存储<br>一般的规范<br>localStorage.name=value 存<br>localStorage.name 取<br>delete localStorage.name 删除一条<br>localStorage.clear() 删除全部<br>规范的存取<br>localStorage.setItem(name,value)<br>localStorage.getItem(name)<br>localStorage.removeItem(name)<br>sessionStorage 临时存储 和 localStorage 一样用法<br>include() 包含<br>template.defaults.openTag=’’; 自定义模板开始样子<br>template.defaults.closeTag=’’; 自定义模板结束样子<br>template.config(‘openTag’,’’)<br>template.config(‘closeTag’,’’)<br>template.config(‘escape’,true/false) true 不默认转译 false 默认转译</p><p>m model 模型<br>v view 视图<br>c controller 控制器<br>scope 范围 作用域<br>then 然后<br>model 模型<br>bind 绑定<br>ng-app=””; 引用其他模块<br>ng-model=”” 数据从哪来<br>ng-bind=”” 或 model 或  数据到哪去<br>ng-init 初始化<br>ng-repeat 循环<br>angular.module(‘名字’,[依赖模块]).controller(‘名字’,function(依赖项){})<br>$scope<br>$http<br>$interval<br>$timeout<br><code>变量</code> 反引号包裹变量 ${} ES6 模板字符串</p><p>|currency:”” 货币<br>date:”” 时间戳转化处理<br>route 路由/状态<br>filter 过滤器<br>directive 指令<br>restrict 类型 E:’element’ C:’class’ M:’comment’ A:’attribute’<br>service 依赖<br>oDate.toString() 获取正常时间<br>creator.ionic.io 做手机端的框架网站不错</p><p>ng-show true false 显示 隐藏<br>ng-hide true false 隐藏 显示<br>ng-clock<br>comment 注释<br>bundle 打包<br>transclude 嵌入<br>params 参数<br>provider 提供者<br>.config() 配置<br>$scope.$watch(数据，fn)<br>angular.bind(this 的指向，要改变指向的函数名，参数)<br>template 模板<br>templateUrl:’模板地址’ 模板<br>$ bower install * bower 工具安装组件<br>ReactDOM.render(什么东西，渲染到哪)<br>type=’text/babel’<br>state 状态<br>extends 延伸 继承<br>constructor 创建<br>super 超类/父类<br>component 组件<br>React.Component<br>this.props.属性<br>组件中 ref 和正常的 ID 类似</p><p>vue<br>el：’id’<br>data:{}<br>$index<br>capitalize 首字母大写<br>uppercase 变大写字母<br>lowercase 变小写字母<br>ev.stoppropagation() 阻止冒泡<br>ev.preventDefault() 阻止默认事件 angular<br>bootstrap 开启应用模式<br>copy(复制谁,复制到哪里) 复制/克隆<br>equals(a,b) 比较<br>forEach 循环<br>fromJson 字符串 json 转化成 json<br>extend（obj，obj1，obj2。。。） 扩展</p><p>标签里面属性 transition=”名字” 过渡 动画<br>.名字-<br>transition 过渡<br>transition：时间 让谁变/all ease;<br>enter 进来<br>leave 出去<br>route 路由/状态<br>watch 监控<br>props 存东西 可在替换模板身上用<br>Router-view 状态视图<br>v-link=”{path:名字}”<br>animation:8s test/名字 linear infinite/数值/次数;<br>background-size 背景尺寸<br>contain 以最合适的状态展示 可能会留白<br>cover 尽可能填满<br>nth-child(下标 注意：从 1 开始) 注意:项目不用这个。禁用<br>nth-of-type(下标 注意：从 1 开始) 注意:项目不用这个。禁用<br>background-origin： 背景从哪里开始<br>content-box<br>border-box //盒模型<br>padding-box<br>background-clip： 背景从哪里开切<br>content-box<br>border-box<br>padding-box<br>text 注意：这个 background-clip 前面要加上 webkit-​​​​</p>]]></content>
      
      
      <categories>
          
          <category> 单词 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序</title>
      <link href="/2021/05/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/2021/05/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-冒泡事件的三个阶段"><a href="#一-冒泡事件的三个阶段" class="headerlink" title="一:冒泡事件的三个阶段"></a>一:冒泡事件的三个阶段</h3><p>官网–小程序框架–事件系统</p><ol><li>捕获（从外向内捕获)</li><li>执行目标阶段</li><li>冒泡（从内向外冒泡)</li></ol><p>定义:捕获是从祖先元素捕获到子元素,捕获之后就执行这个事件，执行完事件后依次冒泡到祖先元素,继而触发他们的事件。</p><h3 id="二-小程序的事件"><a href="#二-小程序的事件" class="headerlink" title="二:小程序的事件:"></a>二:小程序的事件:</h3><p>官网–小程序框架–事件系统</p><p>冒泡:bind bindtop=”事件名”非冒泡:catch catchtop=“事件名”</p><h3 id="三-路由跳转"><a href="#三-路由跳转" class="headerlink" title="三:路由跳转:"></a>三:路由跳转:</h3><p>官网–API—路由</p><p>参数:url 必填参数 success 成功回调 fail:失败回调</p><p>方法一:wx.navigateTo:保留当前页面，跳转到应用内的某个页面。</p><p>方法二:wx.redirectTo:关闭当前页面,跳转到应用内的某个页面。</p><p>方法三:wx.relaunch:关闭所有页面，打开到应用内的某个页面。</p><h3 id="四-小程序的生命周期"><a href="#四-小程序的生命周期" class="headerlink" title="四:小程序的生命周期"></a>四:小程序的生命周期</h3><p><strong>官网–指南–小程序框架-页面生命周期视图线程</strong></p><ol><li>初始化-</li><li>页面初始化完成向服务层要数据–</li><li>要到数据后初次渲染页面-</li><li>通知服务层渲染完成服务层执行 onReady)</li></ol><p><strong>服务线程:</strong></p><ol><li>创建页面的实例，在这个创建的过程中执行了 onLoad onShow 这两个钩子函数</li><li>在页面的需求,可多次使用 onShow onHide</li><li>当关团页面时，执行 onUnload 进行销毁页面。</li></ol><p><strong>注:</strong><br>onload 和 onReady onUnload 这三个钩子函数只能执行一次,onShow 在使用时注意它会执行多谊,性能就会差。</p><h3 id="五-获取用户基本信息"><a href="#五-获取用户基本信息" class="headerlink" title="五:获取用户基本信息:"></a>五:获取用户基本信息:</h3><ol><li>组件-表单信息–button</li><li>API–用户信息–wx.getUserProfilewx.getUserProfile:获取用户信息。</li></ol><p>页面产生点击事件（例如 button 上 bindtap 的回调中）后才可调用,每次请求都会弹出授权窗口,用户同意后返回 userInfo。<br>该接口用于替换 wx.getUserInfo (旧的获取用户基本信息的方法)，desc 这个参数值是必须要有的:声明获取用户个人信息后的用途,</p><blockquote><p><strong>官网–组件–视图容器–</strong></p></blockquote><p><strong>一、swiper:</strong></p><p>滑块视图容器。其中只可放置 swiper-item 组件，否则会导致未定义的行为。</p><p>属性:</p><p>l. indicator-dots:是否显示面板指示点 2. indicator-color:指示点颜色 3. indicator-active-color:当前选中的指示点颜色</p><p><strong>二、 icon 字体图标的使用:</strong></p><p>阿里图标-选择图标加入购物车-点击购物车-创建项目名-打开项目-点击 font class-打开链接-复制 css 到项目中-引入 css 文件–复制字体图标名到标签的 class 中</p><p><strong>三、scroll-view:可滚动视图区域。使用竖向滚动时，需要给 scroll-view 一个固定高度.</strong></p><p>属性:</p><p>l. scroll-x :允许横向滚动 2. scroll-y :允许纵向滚动 3. enable-flex:启用 flexbox 布局。开启后，当前节点声明了 display: flex 就会成为 flex container，并作用于其孩子节点。</p><p><strong>四、单行文本溢出，省略号代替:</strong></p><p>white-space : nowrap;/<em>不换行</em>/<br>overflow: hidden; /<em>溢出文本隐藏</em>/<br>text-overflow: ellipsis;/<em>溢出文本省略号代替</em>/</p><p><strong>五、多行文本溢出，省略号代替:</strong></p><p>overflow:hidden;/<em>溢出文本隐藏</em>/<br>text-overflow: ellipsis;/<em>溢出文本省略号代替</em>/display :-webkit-box;/<em>基于 webkit 内核</em>/<br>-webkit-box-orient :vertical; /<em>设置对齐方式</em>/-webkit-line-clamp : 2;/<em>设置多行的行数</em>/</p><p><strong>六、启动服务器:</strong></p><p>l.npm i express -s2.node app .js</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20道面试题测下你前端基础如何</title>
      <link href="/2021/05/03/20%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B5%8B%E4%B8%8B%E4%BD%A0%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%A6%82%E4%BD%95/"/>
      <url>/2021/05/03/20%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B5%8B%E4%B8%8B%E4%BD%A0%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%A6%82%E4%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下面为我为大家精选的 22 道面试题</p><p><strong>1.请说出三种 meta 标签的作用？</strong></p><p>说明：我会用知识点引导 meta 标签的常用用法</p><p>答：</p><p><strong>2.说出你工作中最常用的五个标签，并说明应用场景？</strong></p><p>说明：看似简单，却能根据你回答的标签和用法来判断你代码的语义化和书写规范。</p><p>答：</p><p><strong>3.box-sizing 的取值和相应的作用？</strong></p><p>说明：我会用知识点引导盒子模型</p><p>答：</p><p><strong>4.让子元素 position:absolute 生效，父元素应该怎么设置？</strong></p><p>说明：初学者在这里有个误区</p><p>答：</p><p><strong>5.position 设置为 absolute 的 div 和 span 分别是什么样子？</strong></p><p>说明：我会用知识点引导 position 的具体作用</p><p>答：</p><p><strong>6.margin 穿透问题怎么解决？</strong></p><p>说明：这里我会详细说下 BFC</p><p>答：</p><p><strong>7.什么是 em 和 rem，他们的区别在哪？</strong></p><p>说明：这里有记忆不准的地方</p><p>答：</p><p><strong>8.简单说下 bootstrap 栅格系统的实现原理？【以及其他由此引发的面试题】</strong></p><p>说明：这里有大量的面试问法，因为栅格系统的原理被应用到目前所有流行的 UI 框架，引发问题，比如：哪个属性让一个 col 即使没有内容也会占据它的位置？等等</p><p>答：</p><p><strong>9.如何阻止事件冒泡？</strong></p><p>说明：基本功</p><p>答：</p><p><strong>10.【代码题】变量提升？</strong></p><p>说明：百年不变的经典题目，而且出场率特别高</p><p>答：</p><p><strong>11.如何实现原型替换？</strong></p><p>说明：这个首先得知道什么是原型</p><p>答：</p><p><strong>12.简单说下 this 指向的具体规则？</strong></p><p>说明：基本功</p><p>答：</p><p><strong>13.什么是闭包？</strong></p><p>说明：组建封装的先行者</p><p>答：</p><p><strong>14.let 和 var 有什么区别？请举例说明。</strong></p><p>说明：别以为很简单，</p><p>答：</p><p><strong>15.模块在同一个页面引入两次，会引起几次 js 渲染？为什么？</strong></p><p>说明：假如你猜对了渲染次数，可能会败在为什么</p><p>答：</p><p><strong>16.如何统一管理 promise 的错误处理函数？</strong></p><p>说明：用过的人都知道</p><p>答：</p><p><strong>17.promise 的 resolve 函数中最多能携带几个参数？</strong></p><p>说明：猜吧</p><p>答：</p><p><strong>18.说一下你在工作中是如何应用 promise 的？</strong></p><p>说明：结合实际来说，我会用知识点引导 promise 的原理和其他用法</p><p>答：</p><p><strong>19.从那些方面可以提升前端性能？</strong></p><p>说明：这个可以列个 1，2，3，4，5</p><p>答：</p><p><strong>20.怎么处理移动端兼容性问题？</strong></p><p>说明：不经历你可能不知道</p><p>答：</p><p><strong>21.你觉得怎样的命名方式才比较规范？结合实例说明</strong></p><p>说明：驼峰？那只是皮毛</p><p>答：</p><p><strong>22.你在平时浏览哪些网站？都有什么样的收获？</strong></p><p>说明：github，掘金，博客园，csdn？我会教你更能打动面试官的回答</p><p>答：</p><p>新增题目:</p><p><strong>01.请说下 1==2==0，1===2===0 的结果？</strong></p><p>说明:值比较和类型比较</p><p>答:</p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建</title>
      <link href="/2021/04/27/hexo%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/04/27/hexo%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现在市面上的博客很多，如 CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。</p><p>而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。</p><p>那么就有第三种选择，直接在 github page 平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且 hexo 作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。</p><h1 id="Hexo-简介"><a href="#Hexo-简介" class="headerlink" title="Hexo 简介"></a>Hexo 简介</h1><p>Hexo 是一款基于 Node.js 的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在 GitHub 和 Coding 上，是搭建博客的首选框架。大家可以进入<a href="https://hexo.bootcss.com/">hexo 官网</a>进行详细查看，因为 Hexo 的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><p>教程分三个部分:</p><ul><li>第一部分：hexo 的初级搭建还有部署到 github page 上，以及个人域名的绑定。</li></ul><ul><li>第二部分：hexo 的基本配置，更换主题，实现多终端工作，以及在 coding page 部署实现国内外分流</li></ul><ul><li>第三部分：hexo 添加各种功能，包括搜索的 SEO，阅读量统计，访问量统计和评论系统等。</li></ul><hr><h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><p>hexo 的初级搭建还有部署到 github page 上，以及个人域名的绑定。</p><h1 id="Hexo-搭建步骤"><a href="#Hexo-搭建步骤" class="headerlink" title="Hexo 搭建步骤"></a>Hexo 搭建步骤</h1><ol><li>安装 Git</li><li>安装 Node.js</li><li>安装 Hexo</li><li>GitHub 创建个人仓库</li><li>生成 SSH 添加到 GitHub</li><li>将 hexo 部署到 GitHub</li><li>设置个人域名</li><li>发布文章</li></ol><h1 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h1><p>Git 是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的 hexo 博客文章，上传到 GitHub 的工具。Git 非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的 Git 教程写的非常好，大家可以了解一下。Git 教程</p><p>windows：到 git 官网上下载,Download git,下载后会有一个 Git Bash 的命令行工具，以后就用这个工具来使用 git。</p><p>linux：对 linux 来说实在是太简单了，因为最早的 git 就是在 linux 上编写的，只需要一行代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>安装好后，用 git –version 来查看一下版本</p><h1 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h1><p>Hexo 是基于 nodeJS 编写的，所以需要安装一下 nodeJs 和里面的 npm 工具。</p><p>windows：nodejs 选择 LTS 版本就行了。</p><p>linux：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>安装完后，打开命令行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node - v;</span><br><span class="line">npm - v;</span><br></pre></td></tr></table></figure><p>检查一下有没有安装成功</p><p>顺便说一下，windows 在 git 安装完后，就可以直接使用 git bash 来敲命令行了，不用自带的 cmd，cmd 有点难用。</p><h1 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h1><p>前面 git 和 nodejs 安装好后，就可以安装 hexo 了，你可以先创建一个文件夹 blog，然后 cd 到这个文件夹下（或者在这个文件夹下直接右键 git bash 打开）。</p><p>输入命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>依旧用 hexo -v 查看一下版本</p><p>至此就全部安装完了。</p><p>接下来初始化一下 hexo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><p>这个 myblog 可以自己取什么名字都行，然后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myblog <span class="comment">//进入这个 myblog 文件夹</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>也可以在我的 GitHub 克隆：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:Gjiayu/hexojc.git</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><p>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>_config.yml: 博客的配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>打开 hexo 的服务，在浏览器输入 localhost:4000 就可以看到你生成的博客了。</p><p>使用 ctrl+c 可以把服务关掉。</p><h1 id="GitHub-创建个人仓库"><a href="#GitHub-创建个人仓库" class="headerlink" title="GitHub 创建个人仓库"></a>GitHub 创建个人仓库</h1><p>首先，你先要有一个 GitHub 账户，去注册一个吧。</p><p>注册完登录后，在 GitHub.com 中看到一个 New repository，新建仓库</p><p>创建一个和你用户名相同的仓库，后面加<code>.github.io</code>，只有这样，将来要部署到 GitHub page 的时候，才会被识别，也就是 xxxx.github.io，其中 xxx 就是你注册 GitHub 的用户名。我这里是已经建过了。</p><p>点击 <code>create repository</code>。</p><h1 id="生成-SSH-添加到-GitHub"><a href="#生成-SSH-添加到-GitHub" class="headerlink" title="生成 SSH 添加到 GitHub"></a>生成 SSH 添加到 GitHub</h1><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa 是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub 是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接 GitHub 自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过 git 上传你的文件到 GitHub 上。</p><h1 id="将-hexo-部署到-GitHub"><a href="#将-hexo-部署到-GitHub" class="headerlink" title="将 hexo 部署到 GitHub"></a>将 hexo 部署到 GitHub</h1><p>这一步，我们就可以将 hexo 和 GitHub 关联起来，也就是将 hexo 生成的文章部署到 GitHub 上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName 就是你的 GitHub 账户</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">type: git;</span><br><span class="line">repo:<span class="comment">//github.com/YourgithubName/YourgithubName.github.io.git</span></span><br><span class="line">branch: master;</span><br></pre></td></tr></table></figure><p>这个时候需要先安装 deploy-git ，也就是部署的命令,这样你才能用命令部署到 GitHub。</p><p>npm install hexo-deployer-git –save</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>其中 hexo clean 清除了你之前生成的东西，也可以不加。<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g 缩写<br>hexo deploy 部署文章，可以用 hexo d 缩写</p><p>注意 deploy 时可能要你输入 username 和 password。</p><p>过一会儿就可以在<a href="http://yourname.github.io/">http://yourname.github.io</a> 这个网站看到你的博客了！！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 3 计划放弃支持 IE11</title>
      <link href="/2021/04/20/Vue%203%20%E8%AE%A1%E5%88%92%E6%94%BE%E5%BC%83%E6%94%AF%E6%8C%81%20IE11/"/>
      <url>/2021/04/20/Vue%203%20%E8%AE%A1%E5%88%92%E6%94%BE%E5%BC%83%E6%94%AF%E6%8C%81%20IE11/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue-3-计划放弃支持-IE11"><a href="#Vue-3-计划放弃支持-IE11" class="headerlink" title="Vue 3 计划放弃支持 IE11"></a>Vue 3 计划放弃支持 IE11</h1><p>Vue.js 作者尤雨溪就 Vue 3 支持 IE11 的计划提交了新提案。</p><p><img src="https://cdn.jsdelivr.net/gh/gjiayu/picture@master/640.png" alt="alt text"></p><p>提案摘要：</p><ol><li><p>Vue 3 将不会支持 IE11</p></li><li><p>原定投入 Vue 3 IE11 支持的精力将投入给 2.7，移植 3.x 兼容的新功能，包括：</p></li></ol><ul><li>Composition API</li></ul><ul><li><code>&lt;script setup&gt;</code> 以及其它新的单文件组件特性</li></ul><ul><li>emits 选项</li></ul><ul><li>TS 类型改进</li></ul><ul><li>Vite 官方整合</li></ul><p>尤雨溪解释了提交此提案的原因，按照最初的计划，Vue 3 正式发布后会添加对 IE11 的支持。在后续的开发过程中，团队对 IE11 兼容性进行了研究和实验，由于其涉及的复杂性和手头上的其他工作量比较大，所以支持 IE11 的开发工作一再被延后。</p><p>现在再重新审视「Vue 3 支持 IE11」计划时，大环境已经有所改变。例如微软积极推广 Edge 从而降低用户对 IE 的依赖，甚至微软自家的项目 (Microsoft 365) 也放弃支持 IE11；WordPress 决定放弃支持 IE11；IE11 的全球使用率已低于 1％。因此他认为现在是重新思考 Vue 3 是否要支持 IE11 的时机。</p><p>尤雨溪还提到了在 Vue 3 中支持 IE11 所带来的影响，例如造成长期的维护负担、增加库开发者的开发复杂度、导致部分特性存在行为差异。</p><p>对于确切需要 IE11 支持的用户，官方建议使用 Vue 2。</p><p>⭐<a href="https://github.com/vuejs/rfcs/blob/ie11/active-rfcs/0000-vue3-ie11-support.md">proposal</a><br>⭐<a href="https://zhuanlan.zhihu.com/p/362000763">中文公告</a></p>]]></content>
      
      
      <categories>
          
          <category> 新闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo发生error：spawn failed错误的解决方法</title>
      <link href="/2021/04/20/error%EF%BC%9Aspawn%20failed/"/>
      <url>/2021/04/20/error%EF%BC%9Aspawn%20failed/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p>先是出现错误：</p><p><code>error：spawn failed...</code></p><p>然后经过一些博客的操作会出现以下问题：</p><p><code>fatal: cannot lock ref &#39;HEAD&#39;: unable to resolve reference HEAD: Invalid argument error: src refspec</code></p><p>或者：</p><p><code>error: src refspec HEAD does not match any.</code>等等</p><p>总结一下：</p><p>问题大多是因为<code> git</code> 进行 <code>push</code> 或者 <code>hexo d</code> 的时候改变了一些<code>.deploy_git </code>文件下的内容。</p><p>解决办法：</p><p>删除<code>.deploy_git </code>文件夹;</p><p>输入 <code>git config --global core.autocrlf false</code></p><p>然后，依次执行：</p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo d</code></p><p>问题解决。暴力直接，有效。</p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择器</title>
      <link href="/2021/04/03/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2021/04/03/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>CSS 选择器</p></blockquote><p>⭐<a href="http://cssreference.parryqiu.com/">CSS 可视化文档</a>⭐<a href="https://www.w3school.com.cn/cssref/css_colors.asp">CSS 中的颜色名</a>⭐<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰 Flex 文档</a></p><blockquote><p><code>id</code>:给元素添加类属性 <code>&lt;div id=&quot;name&quot;&gt;</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#name&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>class</code>:给元素添加类属性 <code>&lt;div class=&quot;box&quot;&gt;</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并集：对选择器进行分组，被分组的选择器可以分享相同的声明。用逗号将需要分组的选择器开分。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1,h2,h3,h4,h5,h6&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>交集：两种属性同属一个元素</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.name&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">p#id&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.name1.name2&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后代（派生）：根据元素在位置上的关系定义样式，使用空格隔开，后代选择器尽量不要超过 3 个，不必把每个层级都列出，只需要写关键点即可</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li strong &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>子代：只能选择作为某元素的子元素，只选择子代，往后孙子一代不选择</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 &gt; strong &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>兄弟和相邻兄弟：选择紧接在另一元素后的，并且二者有相同父元素</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 + p &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>属性：对带有指定属性的 HTML 元素设置样式，权重为 10</p></blockquote><p><strong>属性选择器</strong> ：为带有 <code>title</code> 属性的所有元素设置样式<code>[title] &#123;&#125;</code><br><strong>属性和值选择器</strong> ：为 <code>title=&quot;name&quot;</code>的所有元素设置样式，<code>[title=name] &#123;&#125;</code><br><strong>设置表单的样式</strong> ：<code>input[type=&quot;text&quot;] &#123;&#125;</code></p><blockquote><p>伪类：</p></blockquote><p><code>:active</code>：被激活的元素<br><code>:focus</code>：有键盘输入焦点的元素<br><code>:hover</code>：鼠标悬停<br><code>:link</code>：未被访问的链接 a:link {color: pink;}<br><code>:visited</code>：已被访问的链接 a:visited {color: green;}<br><code>:first-child</code>：元素的第一个子元素<br><code>:lang</code>：带有指定 lang</p><blockquote><p>权重：</p></blockquote><p><code>div</code>（1）<br><code>class/类选择器</code>（10）<br><code>id</code>（100）</p><blockquote><p>结构选择器（新增伪类（面试题））</p></blockquote><p><code>:not</code>：排除<br><code>:nth-child(n)</code>：第几个元素 从 1 开始设置<br><code>:nth-child(2n)</code>：偶数元素 从 0 开始设置<br><code>:nth-child(2n+1)</code>：奇数元素<br><code>:nth-of-type(n)</code>：某个元素下同类型的第几个元素<br><code>:nth-last-child</code>：倒数第几个元素<br><code>:first-child-&gt;</code>:<code>nth-child(1)</code>：<br><code>:fisrt-of-type</code>：第一个同级兄弟元素<br><code>:last-of-type</code>：最后一个同级兄弟元素<br><code>:nth-of-type(n)</code>：第几个同级兄弟元素<br><code>:last-child</code>：最后一个子元素<br><code>:only-child</code>：仅有一个子元素<br><code>:only-of-type</code>：只有一个同类型的子元素<br><code>:empty</code>：空内容<br><code>:checked</code>：被选中 主要用在 <code>input</code> 表单元素</p><blockquote><p>属性选择器</p></blockquote><p><code>E[attr=val]</code>：<br><code>E[attr|=val]</code>：只能等于 <code>val</code> 或只能以 <code>val-</code>开头<br><code>E[attr*=val]</code>：包含 <code>val</code> 字符串<br><code>E[attr~=val]</code>：属性值有多个，其中一个是 <code>val</code><br><code>E[attr^=val]</code>：以 <code>val</code> 开头<br><code>E[attr$=val]</code>：以 <code>val</code> 结尾</p><blockquote><p>目标伪类选择器</p></blockquote><p><code>:target()</code>：用来匹配 <code>URL</code> 指向的目标元素（存在 <code>URL</code> 指向该匹配元素时，样式效果才会生效）<br>伪元素：<br><code>:first-line</code>：匹配首行文本，只能用于块级元素<br><code>:first-letter</code>：匹配首字符<br><code>:before/:after</code>：<code>DOM</code> 元素前后插入额外的内容<br>遇到伪元素 <code>before/after</code> 就要加上 <code>content=&#39;&#39;</code><br><code>display</code>: <code>block</code>;：独占一行<br><code>display</code>: <code>inline-block</code>;：不独占一行</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE</title>
      <link href="/2021/03/20/VUE/"/>
      <url>/2021/03/20/VUE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>项目创建</strong></p></blockquote><h3 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h3><p><code>vue ui</code> 和 <code>vue create</code> 项目名称</p><blockquote><p><strong>vue 基础</strong></p></blockquote><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ol><li><p><code>v-on</code>：绑定事件和自定义事件，缩写<code>@</code></p></li><li><p><code>v-bind</code>：绑定自定义属性，缩写<code>:</code></p></li><li><p><code>v-if</code> <code>v-else</code> <code>v-show</code>：条件渲染，区别：v-if 是加载和销毁，<code>v-show</code> 是显示和隐藏控制的是 <code>css</code> 的 <code>display</code> 属性，相同点：都是让元素可见于不可见。</p></li><li><p><code>v-for</code>：循环渲染：需要注意的是必须加 <code>key</code>。为什么加 <code>key</code> 呢？给 <code>vue</code> 虚拟 <code>dom</code> 的算法进行优化的。key 值必须要唯一。虚拟 <code>dom</code> 就是用 <code>js</code> 算出来的。</p></li><li><p><code>v-text</code>，<code>v-html</code>：相同点：都可以渲染数据。不同点 <code>text</code> 只能渲染值以及字符串等，<code>html</code> 专门渲染字符串类型的 <code>dom</code> 片段的。</p></li><li><p><code>v-model</code>：数据双向绑定，专门给表单元素使用，如果给自定义组件使用，会给自定义组件注入一个 <code>value</code> 值和 <code>input</code> 事件；</p></li><li><p><code>v-once</code>：永远显示的是第一次渲染的值内容，使数据失去双向绑定。</p></li><li><p><code>v-clock</code>：防止插槽写法的是为空时页面闪烁，需要配合 <code>css</code> 生效</p></li><li><p><code>v-slot</code>：插槽的指令，缩写<code>#</code></p></li></ol><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><ol><li><p>父传子：父组件给子组件加自定义属性，子组件使用<code>props</code>获取。</p></li><li><p>子传父：父组件给子组件绑定一个自定义事件，子组件用 <code>$emit</code>调用事件名称进行通信</p></li><li><p><code>v-model</code>：给子组件出入一个<code>value</code>值和<code>input</code>函数</p></li><li><p><code>.sync</code>让<code>props</code>变成双向绑定，即子组件可以修改<code>props</code></p></li><li><p><code>vuex</code>： 全局状态管理，不受组件层级影响。</p></li></ol><h3 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h3><p>定义：<code>vue</code>自带的组件</p><h3 id="组件缓存"><a href="#组件缓存" class="headerlink" title="组件缓存"></a>组件缓存</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;keep-alive include=<span class="string">&quot;包含某一个&quot;</span> exclude=<span class="string">&quot;排除某一个&quot;</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态加载组件"><a href="#动态加载组件" class="headerlink" title="动态加载组件"></a>动态加载组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Component is=<span class="string">&quot;dom&quot;</span>&gt;&lt;/Component&gt;</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><ol><li><p><code>stop</code>：禁止冒泡</p></li><li><p><code>prevent</code>：阻止默认事件</p></li><li><p><code>native</code>：绑定原生事件</p></li></ol><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><ol><li><p><code>13</code>和<code>enter</code>：监听回车</p></li><li><p><code>left</code>和<code>right</code>：监听鼠标左击右击</p></li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li><p>创建阶段：<code>beforeCreate</code>和<code>created</code></p></li><li><p>挂在阶段：<code>beforeMounte</code>和<code>mounted</code> 挂在成功后请求接口</p></li><li><p>更新阶段：<code>beforeUpdate</code>和<code>updated</code></p></li><li><p>销毁阶段：<code>beforeDistroy</code>和<code>distroyed</code> 清除全局变量和</p></li></ol><h3 id="watch和computed"><a href="#watch和computed" class="headerlink" title="watch和computed"></a><code>watch</code>和<code>computed</code></h3><p>相同点：都是对数据进行监听的，当数据发生改变时都会触发监听函数。</p><p>不同点：<code>watch</code>对引用类型的值，需要开启深度监听 <code>deep=&quot;true&quot;</code> ;而<code>computed</code>则不受值类型的影响，且<code>computed</code>返回一个新的值</p><h3 id="vue定义-概念"><a href="#vue定义-概念" class="headerlink" title="vue定义-概念"></a><code>vue</code>定义-概念</h3><ol><li>什么是<code>vue</code>？</li></ol><p>以数据驱动视图的进式<code>MVVM</code>模式框架</p><ol start="2"><li><code>vue</code>数据双向绑定原理？</li></ol><p><code>Object.defineProperty</code>。<code>vue3</code>是<code>es6proxy</code> 利用的是<code>Object.defineProperty</code>方法里的<code>set</code>和<code>get</code>函数。</p><blockquote><p>vue-router 路由</p></blockquote><h3 id="路由组成部分"><a href="#路由组成部分" class="headerlink" title="路由组成部分"></a>路由组成部分</h3><p>路由配置，导航，视图</p><h3 id="路由跳转方式"><a href="#路由跳转方式" class="headerlink" title="路由跳转方式"></a>路由跳转方式</h3><p>js 跳转叫编程式导航，标签跳转叫声明式导航</p><h3 id="路由配置规则有哪些？"><a href="#路由配置规则有哪些？" class="headerlink" title="路由配置规则有哪些？"></a>路由配置规则有哪些？</h3><p>动态路由，嵌套路由，路由重定向，路由别名</p><h3 id="路由传参方式-重点"><a href="#路由传参方式-重点" class="headerlink" title="路由传参方式 {重点}"></a>路由传参方式 {重点}</h3><ol><li><p><code>query</code> 地址栏用<code>get</code>请求方式传参：<code>？建名=值</code></p></li><li><p><code>params</code> 隐式传参：用<code>params</code>属性配置参数<br>显式传参：动态路由<code>query</code>和<code>params</code>隐式传参的区别:隐式<code>params</code>数据存在内存里，页面刷新会导致数据丢失，而<code>query</code>和显示<code>params</code>由于数据就在地址栏中，刷新页面不丢失</p></li></ol><h3 id="路由的生命周期（路由拦截器-守卫-钩子函数-）"><a href="#路由的生命周期（路由拦截器-守卫-钩子函数-）" class="headerlink" title="路由的生命周期（路由拦截器-守卫-钩子函数.）"></a>路由的生命周期（路由拦截器-守卫-钩子函数.）</h3><p>全局守卫 前置守卫：<code>beforeEach(callback)</code> <code>callback</code> 回调函数接受三个参数：<code>to</code>,<code>from</code>,<code>next</code> 其中 <code>to</code> 表示要进入的下一个路由对象 <code>from</code> 表示当前路由对象 <code>next</code> 函数必须要执行，默认值 <code>true</code>，传入 <code>false</code> 则阻止跳转</p><p>组件内守卫 <code>beforeRouteUpdate</code> 路由准备更新 <code>beforeRouteLeave</code> 路由即将离开 <code>#$router</code>和<code>$route</code></p><p>解释： <code>router</code> 是 <code>vue-router</code> 插件的实例对象 ，包含了路由所有的方法和属性，一般用他来进行路由跳转 <code>route</code> 是指当前路由页面里的路由信息。一般于获取当前路由的传参或路径等。</p><h3 id="vuex-状态管理"><a href="#vuex-状态管理" class="headerlink" title="vuex 状态管理"></a><code>vuex</code> 状态管理</h3><p>解释 <code>vuex</code>：全局状态管理器。也是数据双向响应的。</p><h3 id="vuex-组成部分"><a href="#vuex-组成部分" class="headerlink" title="vuex 组成部分"></a><code>vuex</code> 组成部分</h3><p><code>state</code> 存绪状态的 {核心} 辅助函数：<code>mapState</code></p><p><code>getters</code> 对 <code>state</code> 进行计算 辅助函数：<code>mapGetters</code></p><p><code>mutations</code> 修改 <code>state</code> 的，且只能执行同步代码 原始调用方式：<code>commit</code> 调用</p><p><code>actions</code> 执行异步操作的们不能修改 <code>state</code>，调用 <code>mutations</code> 修改 <code>state</code>。 原始调用方式：<code>dispatch</code> 调用</p><p><code>plugin</code> 安装插件：一般安装本地待久化存绪插件。因为 <code>vuex</code> 数据存在内存里，当页面刷新会丢失。</p><h3 id="vuex-工作流程"><a href="#vuex-工作流程" class="headerlink" title="vuex 工作流程"></a><code>vuex</code> 工作流程</h3><p>客户端操作事件，<code>dispatch</code> 调用一个 <code>action</code><br>对应的 <code>action</code> 处理参数，<code>commit</code> 一个 <code>type</code> 类型<br><code>mutation </code>接收一个<code>type</code>类型触发对应的函数，修改 <code>state</code> 值<br><code>state</code> 更改后重新渲染</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE安装</title>
      <link href="/2021/03/17/VUE%E5%AE%89%E8%A3%85/"/>
      <url>/2021/03/17/VUE%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>安装</p></blockquote><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p><code>Vue</code> 不支持 <code>IE8</code> 及以下版本，因为 <code>Vue</code> 使用了 <code>IE8</code> 无法模拟的 <code>ECMAScript 5</code>特性。但它支持所有兼容 <code>ECMAScript 5</code> 的浏览器。</p><h3 id="语义化版本控制"><a href="#语义化版本控制" class="headerlink" title="语义化版本控制"></a>语义化版本控制</h3><p>Vue 在其所有项目中公布的功能和行为都遵循语义化版本控制。对于未公布的或内部暴露的行为，其变更会描述在发布说明中。</p><h3 id="Vue-Devtools"><a href="#Vue-Devtools" class="headerlink" title="Vue Devtools"></a>Vue Devtools</h3><p>在使用 Vue 时，我们推荐在你的浏览器上安装 <a href="https://github.com/vuejs/vue-devtools#vue-devtools"><code>Vue Devtools</code></a>。它允许你在一个更友好的界面中审查和调试 <code>Vue</code> 应用。</p><h3 id="直接用-lt-script-gt-引入"><a href="#直接用-lt-script-gt-引入" class="headerlink" title="直接用 &lt;script&gt; 引入"></a>直接用 <code>&lt;script&gt;</code> 引入</h3><p>直接下载并用 <code>&lt;script&gt;</code> 标签引入，<code>Vue</code> 会被注册为一个全局变量。</p><blockquote><p>在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告!</p></blockquote><blockquote><p><code>开发版本</code> 包含完整的警告和调试模式</p></blockquote><blockquote><p><code>生产版本</code> 删除了警告，33.30KB min+gzip</p></blockquote><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>对于制作原型或学习，你可以这样使用最新版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果你使用原生 ES Modules，这里也有一个兼容 ES Module 的构建文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span></span><br><span class="line">  <span class="string">&#x27;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js&#x27;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>你可以在 <a href="https://cdn.jsdelivr.net/npm/vue/">cdn.jsdelivr.net/npm/vue</a> 浏览 NPM 包的源代码。</p><p>Vue 也可以在 <a href="https://unpkg.com/vue@2.6.12/dist/vue.js">unpkg</a> 和 <a href="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.12/vue.js">cdnjs</a> 上获取 (cdnjs 的版本更新可能略滞后)。</p><p>请确认了解<a href="https://vuejs.bootcss.com/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A">不同构建版本</a>并在你发布的站点中使用生产环境版本，把 <code>vue.js</code> 换成 <code>vue.min.js</code>。这是一个更小的构建，可以带来比开发环境下更快的速度体验。</p><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>在用 Vue 构建大型应用时推荐使用 NPM 安装[1]。NPM 能很好地和诸如 <code>webpack</code> 或 <code>Browserify</code> 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 最新稳定版</span><br><span class="line"></span><br><span class="line">$ npm install vue</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE-ROUTER</title>
      <link href="/2021/03/03/VUE-ROUTER/"/>
      <url>/2021/03/03/VUE-ROUTER/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="什么是路由？"><a href="#什么是路由？" class="headerlink" title="什么是路由？"></a>什么是路由？</h3><p>路由是根据不同的 <code>URL</code> 地址屏现不同的内容或页面</p><blockquote><p>vue 项目又叫单页面项目：<code>spa</code> 整个项目只有一个 <code>index.html</code></p></blockquote><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p>hash 类型的路由 <code>history</code> 历史记录的路由，用 <code>h5</code> 新 <code>api</code> 封装的 <code>VueRouter</code> 让地址栏匹配并显示我们设置的组件</p><h3 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h3><p>显示路由的组件</p><h3 id="vue-router-安装"><a href="#vue-router-安装" class="headerlink" title="vue-router 安装"></a>vue-router 安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm i vue-router -S</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p> 需要用 <code>vue.use</code> 安装</p></li><li><p> 配置 <code>new VueRouter(&#123;&#125;)</code></p></li><li><p> 配置项：<code>&#123;routers:[&#123;path:&quot;匹配的地址&quot;,component:显示的组件&#125;]&#125;</code></p></li><li><p> 露出去，并在 <code>main.js </code>中引入，挂载到实例上。</p></li></ol><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>什么是路由？</p><p>根据 url 地址的变化，皇现不同的页面或内容。</p><h3 id="vue-router-的路由组件"><a href="#vue-router-的路由组件" class="headerlink" title="vue-router 的路由组件"></a>vue-router 的路由组件</h3><ol><li><p>导航组件</p><p><code>&lt;router-link&gt;</code></p></li><li><p>路由视图组件</p><p><code>&lt;router-view&gt;</code></p></li></ol><h3 id="js-跳转加-编程式的导航"><a href="#js-跳转加-编程式的导航" class="headerlink" title="js 跳转加{编程式的导航}"></a>js 跳转加{编程式的导航}</h3><p>标签跳转叫<code>声明式</code> 昨天学了 <code>router-link</code> 这是标签跳转 <code>router-link </code>会被渲染变成 <code>a </code>标签</p><h3 id="router："><a href="#router：" class="headerlink" title="router："></a>router：</h3><p><code>push</code> 向历史记录添加一条 <code>replace</code> 换掉当前路由地址 <code>go</code> 前进后退值是数字</p><h3 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h3><p>用 js 跳转就叫编程式导航，使用<code>$router</code></p><h3 id="router和-route-区别？"><a href="#router和-route-区别？" class="headerlink" title="$router和$route 区别？"></a>$router和$route 区别？</h3><p><code>router</code>是路由的实例对象，包含了所有路由的方法和特性，一般用于操作路由跳转等。</p><p><code>route</code>是当前路由的信息对象，一般用于读取该路由的信息，比如取参数。</p><h3 id="声明式导航"><a href="#声明式导航" class="headerlink" title="声明式导航"></a>声明式导航</h3><p>标签<code>router-link</code>叫声明式导航，通过路由内置组件跳转， 核心属性：<code>to</code>，值是要跳转的路径。 其他属性：<code>replace</code>：替换当前路由，<code>exact</code>：精确匹配，<code>active-class</code>：绑定样式，<code>tag</code>：更改标签渲染类型，默认值是 a 标签。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>一个摸板，接受不同的参数，加载相同数据</p><h3 id="功能分类"><a href="#功能分类" class="headerlink" title="功能分类"></a>功能分类</h3><p>动态路由：动态匹配部分字段是参数，可以使用 <code>route</code> 对象获取，是路由传参的一种方式，</p><h3 id="使用场景分类"><a href="#使用场景分类" class="headerlink" title="使用场景分类"></a>使用场景分类</h3><p>动态路由，一个模块，接受不同的参数，加载相同数据结构</p><h3 id="动态路由-1"><a href="#动态路由-1" class="headerlink" title="动态路由"></a>动态路由</h3><p>一个路由可以匹配多个地址，基于同一根路径。</p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>和动态路由类似，也是基于同一个根路径。是一组拥有有各自视图组件的路由。</p><h3 id="路由传参的三种方式"><a href="#路由传参的三种方式" class="headerlink" title="路由传参的三种方式"></a>路由传参的三种方式</h3><p><code>query</code> 在地址栏显示？<code>建名=值</code><br><code>params</code> 隐式传参：使用 <code>params</code> 配置传递参数，页面刷新会导致值丢失。 跳转路由时，必须使用 <code>name</code> 属性即路由名称跳转。<br><code>params</code> 显示传参：动态路由 . 优雅，刷新页面不丢值 #常见问题<br>使用 <code>params</code> 传参，跳转地址配置项必须是 <code>name</code>，也就是路由的名称。<br>跳转时用 <code>name</code> 比 <code>path </code>的重低<br>标签跳转，重复进入不会报错，使用 <code>js</code> 跳转，如果重复就会报错。<br>当使用活样式的时候，路由会匹配。可以使用 <code>exact</code> 确保路由精确匹配。<br>嵌套路由，子级路由组件必须要在上级路由组件中显示，也就是说，父级组件必须要使用 <code>router-view</code> 组件，才能显示子级路由。</p><h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>访问一个路由，自动跳转到另一个路由，叫重定向。用于引导用户。使用场景：404 容错页面，当访问一个不存在的路由时，跳转到路由，</p><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>使用 <code>alias</code> 给路由起一个别名，相当于该路由匹配拥有多个名称。无论访问哪个名称都是显示该组件。和重定向不同的，地址不变。使用场景：比如新旧网址替换过渡时期，</p><h4 id="优化项"><a href="#优化项" class="headerlink" title="优化项"></a>优化项</h4><p>组件懒加载：使用<code> es6</code> 新语法：<code>import</code> 函数，加载组件。只有当用户操作读取文件时，才去请求该文件。节省了流量和性能。<br>在组件懒加载的 <code>import</code> 函数里使用 <code>webpackChunkName</code> 给打包后的组件取一个名字。方便后续调式程序</p><blockquote><p>凯麦尔哟你的一瞥令我激动难眠 你今天的容貌像十四的月亮一般 妒火中的太阳将油污泼在你芳颜 你面部因此留下一处难消的斑点 油污在羞花之貌没造成颗粒污点 那杰作是美人痣使你显得更灿烂 如花似玉的美貌让我痴情和迷恋 美丽的双眸恰似闪烁的电灯一般 鲜红透明的双唇胜过迷人的石榴 碧玉般的齐齿后藏着诱人的舌头 钩心的黛眉好似十月初升的月牙 贫贱或是帝王在你面前不分上下 奇花是眼睛的卫士睫毛是其长枪 每看我一眼你那长枪就把心刺伤 秀发哟就像我情敌的心神秘莫测 在心海柳丝般漂浮留下几多苦涩 你纤细的双手白嫩透明熠熠闪耀 用我粗糙的手抚慰岂不磨出水泡 你的玉体犹如那透彻的钻石精品 用凤仙花汁染饰的指甲泛着红韵 凯麦尔哟你苗条的身姿仿佛桧柏 从没见过哪位佳丽像你这般可爱 诗人在见到你的地方顷刻间凝固 我不是异教徒而是你虔诚的信徒</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
